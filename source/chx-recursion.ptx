<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="recursion-in-java">
    <title>Recursion in Java</title>
    <introduction>
    </introduction>

    <section xml:id="basic-recursion">
        <title>Basic Recursion</title>
        <p>
            In this chapter, we will explore how to translate your recursive logic from Python to Java. While the core concepts of recursion remain the same, the syntax and structure of your code will change somewhat.

        </p>
            <p><idx>recursion</idx>
                As you may know from Python, <term>recursion</term> is a powerful problem-solving technique involving base cases and recursive steps in which a function or method calls itself. When moving to Java, the core logic you've learned remains identical. The challenge is adapting that logic to Java's statically-typed, class-based syntax.
            </p>
            <p>
                Let's take the familiar factorial function (which calculates the factorial of a number, namely the product of all positive integers from 1 to n). The logical steps in the code are the same, but the implementation details change.
            </p>
            <p>
                Here is the standard implementation in Python:
            </p>
            <program interactive="activecode" language="python">
                <code>
                def factorial(n):
                    # Base Case: 0! or 1! is 1
                    if n &lt;= 1:
                        return 1
                    # Recursive Step: n * (n-1)!
                    else:
                        return n * factorial(n - 1)

                # Let's calculate the factorial of 5.
                x = 5
                print("The factorial of " + x + " is: " + result)
                </code> <tests> </tests>
            </program>
            <p>
               The Java version follows the same recursive logic but requires three key syntax changes: the method must be inside a class, you must declare the parameter and return types (<c>int n</c> and <c>int return</c>), and you use <c>public static</c> to make it callable from <c>main</c>. The base case and recursive step remain conceptually identical.
            </p>

            <p>
                Here is the equivalent Java code:
            </p>

            <program interactive="activecode" language="java">
                <code>
                public class Main {
                    // A recursive function to calculate the factorial of a number.
                    public static int factorial(int n) {
                        // Base case: factorial of 0 or 1 is 1.
                        if (n &lt;= 1) {
                            return 1;
                        }
                        // Recursive step.
                        return n * factorial(n - 1);
                    }

                    // Let's calculate the factorial of 5.
                    public static void main(String[] args) {
                        int x = 5; 
                        int result = Main.factorial(x); // Call the existing factorial method.
                        // Print the result.
                        System.out.println("The factorial of " + x + " is: " + result);
                    }
                }
                </code>
            </program>
            <p>
                Notice the key differences: instead of <c>def</c>, the method signature <c>public static int</c> declares its visibility, that it belongs to the class rather than an object, and that it returns an <c>int</c>. All logic is contained within curly braces <c>{}</c>.
            </p>
    </section>

    <section xml:id="java-patterns-for-recursion">
        <title>Common Recursive Patterns</title>

            <p>
                You're likely familiar with how some recursive algorithms, like the naive Fibonacci implementation, are elegant but inefficient due to redundant calculations. In Java, a common and robust pattern to solve this is using a private helper method. This separates the clean, public-facing API from the more complex internal recursion.
            </p>
            <p>
                The following example demonstrates this pattern. The public <c>fib</c> method provides a simple entry point, while the private <c>fibHelper</c> method performs the efficient recursion by carrying its state (the previous two numbers) in its parameters.
            </p>
            <program interactive="activecode" language="java">
                <code>
                class Main {
                    // A standard recursive Fibonacci function
                    public static int fib(int n) {
                        if (n &lt;= 0) { // Base case for F(0)
                            return 0;
                        } else if (n == 1) { // Base case for F(1)
                            return 1;
                        } else { // Recursive step for F(n) = F(n-1) + F(n-2)
                            return fib(n - 1) + fib(n - 2);
                        }
                    }
                    public static void main(String[] args) {
                        // Test cases
                        System.out.println("Fibonacci of 0: " + fib(0)); // Expected: 0
                        System.out.println("Fibonacci of 1: " + fib(1)); // Expected: 1
                        System.out.println("Fibonacci of 2: " + fib(2)); // Expected: 1
                        System.out.println("Fibonacci of 3: " + fib(3)); // Expected: 2
                        System.out.println("Fibonacci of 5: " + fib(5)); // Expected: 5
                        System.out.println("Fibonacci of 10: " + fib(10)); // Expected: 55
                    }
                }
                </code> <tests> </tests>
            </program>
            <p>
                This public/private helper pattern is a cornerstone of good recursive design in Java, providing both efficiency and a clean interface.
            </p>
    </section>

    <section xml:id="recursion-limits-in-java">
        <title>Recursion Limits: Python vs. Java</title>
        <p>
            The consequence of deep recursion, running out of stack space, is a concept you've already encountered in Python. Java handles this in a very similar way, throwing an error when the call stack depth is exceeded.
        </p>
        <p>
            The key difference is the name of the error:
        </p>
        <ul>
            <li>In Python, this raises a <c>RecursionError</c>.</li>
            <li>In Java, this throws a <c>StackOverflowError</c>.</li>
        </ul>
        <p>
            Neither language supports <idx> tail call optimization </idx><term>tail call optimization</term>, so the practical limits on recursion depth are a factor in both. If an algorithm requires thousands of recursive calls, an iterative (loop-based) approach is the preferred solution in both Python and Java.
        </p>
        <program language="java">
            <code>
                public class Crash {

                    public static void causeStackOverflow() {
                        // This method calls itself endlessly without a stopping condition (a base case).
                        // Each call adds a new layer to the program's call stack.
                        // Eventually, the stack runs out of space, causing the error.
                        causeStackOverflow();
                    }

                    // A main method is required to run the program.
                    public static void main(String[] args) {
                        System.out.println("Calling the recursive method... this will end in an error!");
                        
                        // This line starts the infinite recursion.
                        causeStackOverflow();
                    }
                }
            </code>
        </program>
    </section>
</chapter>