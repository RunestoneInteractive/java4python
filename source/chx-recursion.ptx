<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="recursion-in-java">
    <title>Recursion in Java: A Transition from Python</title>

    <section xml:id="translating-recursion-to-java">
        <title>Translating Your Recursive Logic to Java</title>
        <introduction>
            <p>
                As you know from Python, recursion is a powerful problem-solving technique involving base cases and recursive steps. When moving to Java, the core logic you've learned remains identical. The challenge is adapting that logic to Java's statically-typed, class-based syntax.
            </p>
            <p>
                Let's take the familiar factorial function. The logical steps are the same, but the implementation details change.
            </p>
            <p>
                Here is the standard implementation in Python:
            </p>
            <program interactive="activecode" language="python">
                <code>
                def factorial(n):
                    # Base Case: 0! or 1! is 1
                    if n &lt;= 1:
                        return 1
                    # Recursive Step: n * (n-1)!
                    else:
                        return n * factorial(n - 1)

                print(f"5! is {factorial(5)}")
                </code> <tests> </tests>
            </program>
            <p>
                To write this in Java, you must place the function (now called a method) inside a class and declare the data types for its parameters and return value.
            </p>
            <program language="java">
                <code>
                public class Main {
                    // A recursive function to calculate the factorial of a number.
                    public static int factorial(int n) {
                        // Base case: factorial of 0 or 1 is 1.
                        if (n &lt;= 1) {
                            return 1;
                        }
                        // Recursive step.
                        return n * factorial(n - 1);
                    }

                    public static void main(String[] args) {
                        int n = 3; // Let's calculate the factorial of 3.
                        int result = Main.factorial(n); // Call the existing factorial method.
                        System.out.println("The factorial of " + n + " is: " + result); // Output: The factorial of 3 is: 6
                    }
                }
                </code>
            </program>
            <p>
                Notice the key differences: instead of <c>def</c>, the method signature <c>public static int</c> declares its visibility, that it belongs to the class rather than an object, and that it returns an <c>int</c>. All logic is contained within curly braces <c>{}</c>.
            </p>
        </introduction>
    </section>

    <section xml:id="java-patterns-for-recursion">
        <title>Common Recursive Patterns in Java</title>
        <introduction>
            <p>
                You're likely familiar with how some recursive algorithms, like the naive Fibonacci implementation, are elegant but inefficient due to redundant calculations. In Java, a common and robust pattern to solve this is using a private helper method. This separates the clean, public-facing API from the more complex internal recursion.
            </p>
            <p>
                The following example demonstrates this pattern. The public <c>fib</c> method provides a simple entry point, while the private <c>fibHelper</c> method performs the efficient recursion by carrying its state (the previous two numbers) in its parameters.
            </p>
            <program interactive="activecode" language="java">
                <code>
                class Main {
                    // A standard recursive Fibonacci function
                    public static int fib(int n) {
                        if (n &lt;= 0) { // Base case for F(0)
                            return 0;
                        } else if (n == 1) { // Base case for F(1)
                            return 1;
                        } else { // Recursive step for F(n) = F(n-1) + F(n-2)
                            return fib(n - 1) + fib(n - 2);
                        }
                    }
                    public static void main(String[] args) {
                        // Test cases
                        System.out.println("Fibonacci of 0: " + fib(0)); // Expected: 0
                        System.out.println("Fibonacci of 1: " + fib(1)); // Expected: 1
                        System.out.println("Fibonacci of 2: " + fib(2)); // Expected: 1
                        System.out.println("Fibonacci of 3: " + fib(3)); // Expected: 2
                        System.out.println("Fibonacci of 5: " + fib(5)); // Expected: 5
                        System.out.println("Fibonacci of 10: " + fib(10)); // Expected: 55
                    }
                }
                </code> <tests> </tests>
            </program>
            <p>
                This public/private helper pattern is a cornerstone of good recursive design in Java, providing both efficiency and a clean interface.
            </p>
        </introduction>
    </section>

    <section xml:id="recursion-limits-in-java">
        <title>Recursion Limits: Python vs. Java</title>
        <p>
            The consequence of deep recursion, running out of stack space, is a concept you've already encountered in Python. Java handles this in a very similar way, throwing an error when the call stack depth is exceeded.
        </p>
        <p>
            The key difference is the name of the error:
        </p>
        <ul>
            <li>In Python, this raises a <c>RecursionError</c>.</li>
            <li>In Java, this throws a <c>StackOverflowError</c>.</li>
        </ul>
        <p>
            Neither language supports <idx> tail call optimization </idx><term>tail call optimization</term>, so the practical limits on recursion depth are a factor in both. If an algorithm requires thousands of recursive calls, an iterative (loop-based) approach is the preferred solution in both Python and Java.
        </p>
        <program language="java">
            <code>
                public class Crash {

                    public static void causeStackOverflow() {
                        // This method calls itself endlessly without a stopping condition (a base case).
                        // Each call adds a new layer to the program's call stack.
                        // Eventually, the stack runs out of space, causing the error.
                        causeStackOverflow();
                    }

                    // A main method is required to run the program.
                    public static void main(String[] args) {
                        System.out.println("Calling the recursive method... this will end in an error!");
                        
                        // This line starts the infinite recursion.
                        causeStackOverflow();
                    }
                }
            </code>
        </program>
    </section>
</chapter>