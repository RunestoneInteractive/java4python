<?xml version="1.0"?>

<!-- Generated by Docutils 0.19 -->
<chapter xml:id="classes-in-java">
    <title>Classes in Java</title>

<section xml:id="defining-classes-in-java">
    <title>Defining Classes in Java</title>
    <introduction>
        <p>
            You have already seen how to define classes in Java.
            It&#x2019;s unavoidable for even the simplest of programs.
            In this section we will look at how we define classes to create our own data types.
            Lets start by creating a fraction class to extend the set of numeric data types provided by our language.
            The requirements for this new data type are as follows:
        </p>

                <p>
                    <ul>
                        <li>
                            <p>
                                Given a numerator and a denominator create a new Fraction.
                            </p>
                        </li>

                        <li>
                            <p>
                                When a fraction is printed it should be simplified.
                            </p>
                        </li>

                        <li>
                            <p>
                                Two fractions can be added or subtracted
                            </p>
                        </li>

                        <li>
                            <p>
                                Two fractions can be multiplied or divided
                            </p>
                        </li>

                        <li>
                            <p>
                                Two fractions can be compared
                            </p>
                        </li>

                        <li>
                            <p>
                                A fraction and an integer can be added together.
                            </p>
                        </li>

                        <li>
                            <p>
                                Given a list of Fractions that list should be sortable by the default sorting function.
                            </p>
                        </li>
                    </ul>
                </p>

                <p>
                    Here is a mostly complete implementation of a Fraction class in Python that we will refer to throughout this section:
                </p>


                <program interactive="activecode" language="python">
                    <code>
        class Fraction:
            def __init__(self, num, den):
                """
                :param num: The top of the fraction
                :param den: The bottom of the fraction
                """
                self.num = num
                self.den = den
            def __repr__(self):
                if self.num &gt; self.den:
                    retWhole = int(self.num / self.den)
                    retNum = self.num - (retWhole * self.den)
                    return str(retWhole) + " " + str(retNum) + "/" + str(self.den)
                else:
                    return str(self.num) + "/" + str(self.den)
            def show(self):
                print(self.num, "/", self.den)
            def __add__(self, other):
                # convert to a fraction
                other = self.toFract(other)
                newnum = self.num * other.den + self.den * other.num
                newden = self.den * other.den
                common = gcd(newnum, newden)
                return Fraction(int(newnum / common), int(newden / common))
            __radd__ = __add__
            def __lt__(self, other):
                num1 = self.num * other.den
                num2 = self.den * other.num
                return num1 &lt; num2
            def toFract(self, n):
                if isinstance(n, int):
                    other = Fraction(n, 1)
                elif isinstance(n, float):
                    wholePart = int(n)
                    fracPart = n - wholePart
                    # convert to 100ths???
                    fracNum = int(fracPart * 100)
                    newNum = wholePart * 100 + fracNum
                    other = Fraction(newNum, 100)
                elif isinstance(n, Fraction):
                    other = n
                else:
                    print("Error: cannot add a fraction to a ", type(n))
                    return None
                return other
        def gcd(m, n):
            """
            A helper function for Fraction
            """
            while m % n != 0:
                oldm = m
                oldn = n
                m = oldn
                n = oldm % oldn
            return n
        print(sorted([Fraction(5, 16), Fraction(3, 16), Fraction(1, 16) + 1]))
                    </code> <tests> </tests>
                </program>

                <p>
                    <idx>data members</idx>
        The instance variables (<term>data members</term>) we will need for our fraction class are the numerator and denominator. Of course in Python we can add instance variables to a class at any time by simply assigning a value to <c>objectReference.variableName</c>, whereas in Java all data members must be declared up front. 
                </p>

                <p>
        The declarations of instance variables can come at the beginning of the class definition or the end. Cay Horstman, author of <url href="https://horstmann.com/corejava/index.html" visual="https://horstmann.com/corejava/index.html">the &#x201C;Core Java&#x201D; books</url> puts the declarations at the end of the class. I like them at the very beginning so you see the variables that are declared before you begin looking at the code that uses them. With that in mind the first part of the Fraction class definition is as follows: 
                </p>


                <program language="java">
                    <code>
        public class Fraction {
            private Integer numerator;
            private Integer denominator;
        }
                    </code>
                </program>

                <p>
                    Notice that we have declared the numerator and denominator to be <term>private</term>.
                    This means that the compiler will generate an error if another method tries to write code like the following:
                </p>


                <program language="java">
                    <code>
        Fraction f = new Fraction(1,2);
        Integer y = f.numerator * 10;
                    </code>
                </program>

                <p>
                    <idx>getter method</idx>
                    <idx>setter method</idx>
                    Direct access to instance variables is not allowed in Java.
                    Therefore if we legitimately want to be able to access information such as the numerator or the denominator for a particular fraction we must have a <term>getter method</term> that returns the needed value.
                    Hence, it is a very common programming practice to both provide <term>getter methods</term> and <term>setter methods</term> when needed for instance variables in Java.
                </p>


        <program language="java">
            <code>
public Integer getNumerator() {
    return numerator;
}
public void setNumerator(Integer numerator) {
    this.numerator = numerator;
}
public Integer getDenominator() {
    return denominator;
}
public void setDenominator(Integer denominator) {
    this.denominator = denominator;
}
            </code>
        </program>
    </introduction>
</section>

    <section xml:id="writing-a-constructor">
        <title>Writing a constructor</title>

        <p>
            Once you have identified the instance variables for your class the next thing to consider is the constructor.
            In Java, <term>constructors</term> have the same name as the class and are declared public.
            They are declared without a return type.
            So any method that is named the same as the class and has no return type is a constructor.
            Our constructor will take two parameters: the numerator and the denominator.
        </p>


        <program language="java">
            <code>
public Fraction(Integer top, Integer bottom) {
    num = top;
    den = bottom;
}
            </code>
        </program>

        <p>
            <idx><c>this</c></idx>
            There are a couple of important things to notice here.
            First, you will notice that the constructor does not have a <c>self</c> parameter.
            You will also notice that we can simply refer to the instance variables by name without the <c>self</c> prefix, because they have already been declared.
            This allows the Java compiler to do the work of dereferencing the current Java object.
            Java does provide a special variable called <c>this</c> that works like the <c>self</c> variable.
            In Java, <c>this</c> is typically only used when it is needed to differentiate between a parameter or local variable and an instance variable.
            For example this alternate definition of the the Fraction constructor uses <c>this</c> to differentiate between parameters and instance variables.
        </p>


        <program language="java">
            <code>
public Fraction(Integer num, Integer den) {
    this.num = num;
    this.den = den;
}
            </code>
        </program>
    </section>

    <section xml:id="methods">
        <title>Methods</title>

        <introduction>
            <p>
                Now we come to one of the major differences between Java and Python.
                The Python class definition used the special methods for addition and comparison that have the effect of redefining how the standard operators behave: in Python, <c>__add__</c> and <c>__lt__</c> change the behavior of <c>+</c> and <c>&lt;</c>, respectively.
                In Java there is no operator overloading.
                So we will have to write the method for addition a little differently.
            </p>

            <p>
                A point of terminology: Python has both &#x201C;functions&#x201D; (<c>def</c> outside a class) and &#x201C;methods&#x201D; (<c>def</c> inside a class).
                Since Java requires all code to be inside classes, it only has &#x201C;methods.&#x201D; Those from a C++ background might refer to methods as &#x201C;member functions.&#x201D;
            </p>
            <p>
                Before we dive into the <c>add</c> method, it's important to understand how Java passes arguments to methods, as this is a common point of confusion for programmers coming from Python. The terminology is different, but the practical result for objects is effectively identical.
            </p>
            <p>
                <ul>
                    <li>
                        <p>
                            <idx>pass-by-value</idx>
                            <idx>value of the reference</idx>
                            <term>Java is strictly pass-by-value.</term> For primitive types (like <c>int</c>), a copy of the value is passed. For object types (like our <c>Fraction</c>), a copy of the <em><term>value of the reference</term></em> (the memory address) is passed.
                        </p>
                    </li>
                    <li>
                        <p>
                            <idx>pass-by-assignment</idx>
                            <term>Python is pass-by-assignment</term> (or pass-by-object-reference). Since everything in Python is an object, the rule is consistent: a copy of the reference to the object is passed.
                        </p>
                    </li>
                </ul>
            </p>
            <p>
                What does this mean in practice? <strong>For objects, the behavior is the same in both languages.</strong> When you pass a <c>Fraction</c> object to the <c>add</c> method, both the original variable outside the method and the parameter inside the method (<c>otherFrac</c>) refer to the <strong>exact same object</strong> in memory. This allows the method to use the object's getters to read its state. If you were to call a setter method on <c>otherFrac</c>, the change would be reflected in the original object.
            </p>
            <p>
                However, if you reassign the parameter to a completely new object inside the method (e.g., <c>otherFrac = new Fraction(0,1);</c>), it would <em>not</em> affect the original variable outside the method, because you are only changing the local copy of the reference.
            </p>
            <p>
                Let&#x2019;s begin by implementing addition in Java:
            </p>


            <program language="java">
                <code>
public Fraction add(Fraction otherFrac) {
    Integer newNum = otherFrac.getDenominator() * this.numerator +
                             this.denominator * otherFrac.getNumerator();
    Integer newDen = this.denominator * otherFrac.getDenominator();
    Integer common = gcd(newNum, newDen);
    return new Fraction(newNum/common, newDen/common);
}
                </code>
            </program>

            <p>
                First you will notice that the <c>add</c> method is declared as <c>public Fraction</c> The <c>public</c> part means that any other method may call the <c>add</c> method.
                The <c>Fraction</c> part means that <c>add</c> will return a fraction as its result.
            </p>

            <p>
                Second, you will notice that the method makes use of the <c>this</c> variable.
                In this method, <c>this</c> is not necessary, because there is no ambiguity about the <c>numerator</c> and <c>denominator</c> variables.
                So this version of the code is equivalent:
            </p>


            <program language="java">
                <code>
public Fraction add(Fraction otherFrac) {
    Integer newNum = otherFrac.getDenominator() * numerator +
                             denominator * otherFrac.getNumerator();
    Integer newDen = denominator * otherFrac.getDenominator();
    Integer common = gcd(newNum, newDen);
    return new Fraction(newNum/common, newDen/common);
}
                </code>
            </program>

            <p>
                The addition takes place by multiplying each numerator by the opposite denominator before adding.
                This procedure ensures that we are adding two fractions with common denominators.
                Using this approach the denominator is computed by multiplying the two denominators.
                The greatest common divisor method, <c>gcd</c>, is used to find a common divisor to simplify the numerator and denominator in the result.
            </p>

            <p>
                Finally on line 6 a new <c>Fraction</c> is returned as the result of the computation.
                The value that is returned by the return statement must match the value that is specified as part of the declaration.
                So, in this case the return value on line 8 must match the declared value on line 1.
            </p>
        </introduction>


        <subsection>
            <title>Method Signatures and Overloading</title>

            <p>
                Our specification for this project said that we need to be able to add a <c>Fraction</c> to an <c>Integer</c>.
                In Python we can do this by checking the type of the parameter using the <c>isinstance</c> function at runtime.
                Recall that <c>isinstance(1,int)</c> returns <c>True</c> to indicate that 1 is indeed an instance of the <c>int</c> class.
                See the <c>__add__</c> and <c>toFract</c> methods in the Python version of the <c>Fraction</c> class to see how our Python implementation fulfills this requirement.
            </p>

            <p>
                <idx>method overloading</idx>
                In Java we can do runtime type checking, but the compiler will not allow us to pass an Integer to the <c>add</c> method since the parameter has been declared to be a Fraction.
                The way that we solve this problem is by writing another <c>add</c> method with a different set of parameters.
                In Java this practice is legal and common we call this practice <term>method overloading</term>.
            </p>

            <p>
                <idx>signature</idx>
                This idea of method overloading raises a very important difference between Python and Java.
                In Python a method is known by its name only.
                In Java a method is known by its signature.
                The <term>signature</term> of a method includes its name, and the types of all of its parameters.
                The name and the types of the parameters are enough information for the Java compiler to decide which method to call at runtime.
            </p>

            <p>
                To solve the problem of adding an <c>Integer</c> and a <c>Fraction</c> in Java we will overload both the constructor and the <c>add</c> method.
                We will overload the constructor so that if it only receives a single <c>Integer</c> it will convert the <c>Integer</c> into a <c>Fraction</c>.
                We will also overload the <c>add</c> method so that if it receives an <c>Integer</c> as a parameter it will first construct a <c>Fraction</c> from that integer and then add the two <c>Fractions</c> together.
                The new methods that accomplish this task are as follows:
            </p>


            <program language="java">
                <code>
public Fraction(Integer num) {
    this.numerator = num;
    this.denominator = 1;
}
public Fraction add(Integer other) {
    return add(new Fraction(other));
}
                </code>
            </program>

            <p>
                Notice that the overloading approach can provide us with a certain elegance to our code.
                Rather than utilizing if statements to check the types of parameters we just overload methods ahead of time which allows us to call the method we want and allow the compiler to make the decisions for us.
                This way of thinking about programming takes some practice.
            </p>

            <p>
                Our full <c>Fraction</c> class to this point would look like the following.
                You should compile and run the program to see what happens.
            </p>


            <program interactive="activecode" language="java">
                <code>
public class Fraction {
    private Integer numerator;
    private Integer denominator;
    public Fraction(Integer num, Integer den) {
        this.numerator = num;
        this.denominator = den;
    }
    public Fraction(Integer num) {
        this.numerator = num;
        this.denominator = 1;
    }
    public Integer getNumerator() {
        return numerator;
    }
    public Integer getDenominator() {
        return denominator;
    }
    public Fraction add(Fraction other) {
        Integer newNum = other.getDenominator()*this.numerator + this.denominator*other.getNumerator();
        Integer newDen = this.denominator * other.getDenominator();
        Integer common = gcd(newNum,newDen);
        return new Fraction(newNum/common, newDen/common );
    }
    public Fraction add(Integer other) {
        return add(new Fraction(other));
    }
    private static Integer gcd(Integer m, Integer n) {
        while (m % n != 0) {
            Integer oldm = m;
            Integer oldn = n;
            m = oldn;
            n = oldm%oldn;
        }
        return n;
    }
    public static void main(String[] args) {
        Fraction f1 = new Fraction(1,2);
        System.out.println(f1.add(1));
    }
}
                </code> <tests> </tests>
            </program>
        </subsection>

        <subsection>
            <title>Naming Conventions</title>
            <p>
        It is worth pointing out that Java has some very handy naming conventions. It is advisable to both use meaningful names and to follow these naming conventions while developing software in Java for good maintenance and readability of code. 
    </p>

    <p>
        <ul>
            <li>
                <p>
                    Class names should be nouns that are written in UpperCamelCase, namely with the first letter of each word capitalized including the first. 
                    For example, <c>ArrayList</c>, <c>Scanner</c>, <c>StringBuilder</c>, <c>System</c>, etc.
                </p>
            </li>

            <li>
                <p>
                    Method names use lowerCamelCase which start with a verb that describes the action they perform. This means that method names start with a lower case letter, and use upper case for each internal-word method names. For example, <c>isInt()</c>, <c>nextLine()</c>, <c>getDenominator()</c>, <c>setNumerator()</c>, etc.
                </p>
            </li>

            <li>
                <p>
                    Instance variables of a class start with a lower case letter and use lowerCamelCase like method names. For example, <c>count</c>, <c>totalAmount</c>, etc.
                </p>
            </li>

            <li>
                <p>
                    Constants are in all upper case letters or in upper snake case, which also known as screaming snake case, and which is a naming convention in which each word is written in uppercase letters,  separated by underscores. 
                    For example, <c>Math.MAXINT</c> or <c>MAX_INT</c>.
                </p>
            </li>
        </ul>
    </p>
        </subsection>
    </section>

    <section xml:id="inheritance">
        <title>Inheritance</title>

        <introduction>
            <p>
 If you ran the program above you probably noticed that the output is not very satisfying. Chances are your output looked something like this: 
            </p>


            <program language="java">
                <code>
Fraction@6ff3c5b5
                </code>
            </program>

            <p>
                The reason is that we have not yet provided a friendly string representation for our <c>Fraction</c> objects.
                Just like in Python, whenever an object is printed by the <c>println</c> method it must be converted to string format.
                In Python you can control how that looks by writing an <c>__str__</c> method for your class.
                If you do not then you will get the default, which looks something like the above.
            </p>
        </introduction>


        <subsection>
            <title>The <c>Object</c> Class</title>

            <p>
                <idx><c>toString</c></idx>
                In Java, the equivalent of <c>__str__</c> is the <c>toString</c> method.
                Every object in Java already has a <c>toString</c> method defined for it because every class in Java automatically inherits from the <c>Object</c> class.
                The <c>Object</c> class provides default implementations for the following methods.
            </p>

            <p>
                <ul>
                    <li>
                        <p>
                            <c>clone</c>
                        </p>
                    </li>

                    <li>
                        <p>
                            <c>equals</c>
                        </p>
                    </li>

                    <li>
                        <p>
                            <c>finalize</c>
                        </p>
                    </li>

                    <li>
                        <p>
                            <c>getClass</c>
                        </p>
                    </li>

                    <li>
                        <p>
                            <c>hashCode</c>
                        </p>
                    </li>

                    <li>
                        <p>
                            <c>notify</c>
                        </p>
                    </li>

                    <li>
                        <p>
                            <c>notifyAll</c>
                        </p>
                    </li>

                    <li>
                        <p>
                            <c>toString</c>
                        </p>
                    </li>

                    <li>
                        <p>
                            <c>wait</c>
                        </p>
                    </li>
                </ul>
            </p>

            <p>
                We are not interested in most of the methods on that list, and many Java programmers live happy and productive lives without knowing much about most of the methods on that list.
                However, to make our output nicer we will implement the <c>toString</c> method for the <c>Fraction</c> class.
                A simple version of the method is provided below.
            </p>


            <program language="java">
                <code>
public String toString() {
    return numerator.toString() + "/" + denominator.toString();
}
                </code>
            </program>

            <p>
                The other important class for us to implement from the list of methods inherited from <c>Object</c> is the <c>equals</c> method.
                In Java, when two objects are compared using the <c>==</c> operator they are tested to see if they are exactly the same object (that is, do the two objects occupy the same exact space in the computer&#x2019;s memory?).
                This is also the default behavior of the <c>equals</c> method provided by <c>Object</c>.
                The <c>equals</c> method allows us to decide if two objects are equal by looking at their instance variables.
                However it is important to remember that since Java does not have operator overloading <term>if you want to use your</term> <c>equals</c> <term>method you must call it directly</term>.
                Therefore once you write your own <c>equals</c> method:
            </p>


            <program language="java">
                <code>
object1 == object2
                </code>
            </program>

            <p>
                is NOT the same as
            </p>


            <program language="java">
                <code>
object1.equals(object2)
                </code>
            </program>

            <p>
                Here is an <c>equals</c> method for the <c>Fraction</c> class:
            </p>


            <program language="java">
                <code>
public boolean equals(Fraction other) {
    Integer num1 = this.numerator * other.getDenominator();
    Integer num2 = this.denominator * other.getNumerator();
    if (num1 == num2)
        return true;
    else
        return false;
}
                </code>
            </program>

            <p>
                One important thing to remember about <c>equals</c> is that it only checks to see if two objects are equal &#x2013; it does not have any notion of less than or greater than.
                We&#x2019;ll see more about that shortly.
            </p>
        </subsection>


        <subsection>
            <title>Abstract Classes and Methods</title>

            <p>
                <idx>abstract class</idx>
                If we want to make our <c>Fraction</c> class behave like <c>Integer</c>, <c>Double</c>, and the other numeric classes in Java then we need to make a couple of additional modifications to the class.
                The first thing we will do is plug <c>Fraction</c> into the Java class hierarchy at the same place as <c>Integer</c> and its siblings.
                If you look at the documentation for <c>Integer</c> you will see that <c>Integer</c>&#x2019;s parent class is <c>Number</c>.
                Number is an <term>abstract class</term> that specifies several methods that all of its children must implement.
                In Java an abstract class is more than just a placeholder for common methods.
                In Java an abstract class has the power to specify certain methods that all of its children <term>must</term> implement.
                You can trace this power back to the strong typing nature of Java.
            </p>

            <p>
                Here is code that makes the <c>Fraction</c> class a child of <c>Number</c>:
            </p>


            <program language="java">
                <code>
public class Fraction extends Number {
    ...
}
                </code>
            </program>

            <p>
                <idx><c>extends</c></idx>
                The keyword <c>extends</c> tells the compiler that the class <c>Fraction</c> extends, or adds new functionality to the <c>Number</c> class.
                A child class always extends its parent.
            </p>

            <p>
                The methods we must implement if <c>Fraction</c> is going to be a child of <c>Number</c> are:
            </p>

            <p>
                <ul>
                    <li>
                        <p>
                            <c>longValue</c>
                        </p>
                    </li>

                    <li>
                        <p>
                            <c>intValue</c>
                        </p>
                    </li>

                    <li>
                        <p>
                            <c>floatValue</c>
                        </p>
                    </li>

                    <li>
                        <p>
                            <c>doubleValue</c>
                        </p>
                    </li>
                </ul>
            </p>

            <p>
                This really isn&#x2019;t much work for us to implement these methods, as all we have to do is some type conversion and some division:
            </p>


            <program language="java">
                <code>
public double doubleValue() {
    return numerator.doubleValue() / denominator.doubleValue();
}
public float floatValue() {
    return numerator.floatValue() / denominator.floatValue();
}
public int intValue() {
    return numerator.intValue() / denominator.intValue();
}
public long longValue() {
    return numerator.longValue() / denominator.longValue();
}
                </code>
            </program>

            <p>
                <idx>is-a</idx>
                By having the <c>Fraction</c> class extend the <c>Number</c> class we can now pass a <c>Fraction</c> to any Java method that specifies it can receive a <c>Number</c> as one of its parameters.
                For example many Java user interface methods accept any object that is a subclass of <c>Number</c> as a parameter.
                In Java the class hierarchy and the &#x201C;<term>is-a</term>&#x201D; relationships are very important.
                Whereas in Python you can pass any kind of object as a parameter to any method or function, the strong typing of Java makes sure that you only pass an object as a parameter that is of the type specified in the method signature, or one of the children of the type specified.
                When you see a parameter of type <c>Number</c> it&#x2019;s important to remember that an <c>Integer</c> <em>is-a</em> <c>Number</c> and a <c>Double</c> <em>is-a</em> <c>Number</c> and a <c>Fraction</c> <em>is-a</em> <c>Number</c>, because these classes are children of <c>Number</c>.
            </p>

            <p>
                However, and this is a big however, it is important to remember that if you specify <c>Number</c> as the type of a particular parameter then the Java compiler will <term>only let you use the methods of a</term> <c>Number</c>: <c>longValue</c>, <c>intValue</c>, <c>floatValue</c>, and <c>doubleValue</c>.
            </p>

            <p>
                Suppose you try to define a method as follows:
            </p>


            <program language="java">
                <code>
public void test(Number a, Number b) {
    a.add(b);
}
                </code>
            </program>

            <p>
                The Java compiler would give an error because <c>add</c> is not a defined method of the <c>Number</c> class.
                You will <term>still get this error</term> even if all your code that calls this <c>test</c> method passes two <c>Fractions</c> as parameters (remember that <c>Fraction</c> does implement <c>add</c>).
            </p>
        </subsection>
    </section>

    <section xml:id="interfaces">
        <title>Interfaces</title>

        <p>
            <idx><c>Comparable</c></idx>
            <idx>single inheritance</idx>
            Lets turn our attention to making a list of fractions sortable by the standard Java sorting method <c>Collections.sort</c>.
            In Python, we would just need to implement the <c>__cmp__</c> method.
            But in Java we cannot be that informal.
            In Java, things that are sortable must be <c>Comparable</c>.
            Your first thought might be that <c>Comparable</c> is superclass of <c>Number</c>, but that is actually not the case.
            Java only supports <term>single inheritance</term>, that is, a class can have only one parent.
            Although it would be possible to add an additional layer to the class hierarchy it would also complicate things dramatically, because not only are <c>Numbers</c> comparable, but <c>Strings</c> are also <c>Comparable</c> as would many other types.
            For example, we might have a <c>Student</c> class and we want to be able to sort students by their GPA.
            But <c>Student</c> might already extends the class <c>Person</c> for which there would be no natural comparison method.
        </p>

        <p>
            <idx><c>Interface</c></idx>
            Java&#x2019;s answer to this problem is the <c>Interface</c> mechanism.
            Interfaces are like a combination of &#x201C;inheritance&#x201D; and &#x201C;contracts&#x201D; all rolled into one.
            An interface is a <em>specification</em> that says any object that claims it implements this interface must provide the following methods.
            It sounds a little bit like an abstract class, however it is outside the inheritance mechanism.
            You can never create an instance of <c>Comparable</c>.
            Many objects, however, do implement the <c>Comparable</c> interface.
            What does the <c>Comparable</c> interface specify?
        </p>

        <p>
            The <c>Comparable</c> interface says that any object that claims to be <c>Comparable</c> must implement the <c>compareTo</c> method.
            Here is an excerpt from <url href="https://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html#compareTo(T)" visual="https://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html#compareTo(T)">the official documentation</url> for the <c>compareTo</c> method as specified by the <c>Comparable</c> interface.
        </p>


        <program language="text">
            <code>
int compareTo(T o)
Compares this object with the specified object for order. Returns a
negative integer, zero, or a positive integer as this object is less
than, equal to, or greater than the specified object. The
implementor must ensure sgn(x.compareTo(y)) == -sgn(y.compareTo(x)) for
all x and y. (This implies that x.compareTo(y) must throw an exception
iff y.compareTo(x) throws an exception.)
...
            </code>
        </program>

        <p>
            To make our <c>Fraction</c> class <c>Comparable</c> we must modify the class declaration line as follows:
        </p>


        <program language="java">
            <code>
public class Fraction extends Number implements Comparable&lt;Fraction&gt; {
    ...
}
            </code>
        </program>

        <p>
            The specification <c>Comparable&lt;Fraction&gt;</c> makes it clear that <c>Fraction</c> is only comparable with another <c>Fraction</c>.
            The <c>compareTo</c> method could be implemented as follows:
        </p>


        <program language="java">
            <code>
public int compareTo(Fraction other) {
    Integer num1 = this.numerator * other.getDenominator();
    Integer num2 = this.denominator * other.getNumerator();
    return num1 - num2;
}
            </code>
        </program>
    </section>

    <section xml:id="static-member-variables">
        <title>Static member variables</title>

        <p>
            Suppose that you wanted to write a Student class so that the class could keep track of the number of students it had created.
            Although you could do this with a global counter variable that is an ugly solution.
            The right way to do it is to use a static variable.
            In Python we could do this as follows:
        </p>


        <program interactive="activecode" language="python">
            <code>
class Student:
    numStudents = 0
    def __init__(self, id, name):
        self.id = id
        self.name = name
        Student.numStudents = Student.numStudents + 1
def main():
    for i in range(10):
        s = Student(i,"Student-"+str(i))
    print('Number of students:', Student.numStudents)
main()
            </code> <tests> </tests>
        </program>

        <p>
 In Java we would write this same example using a static declaration. 
        </p>


        <program interactive="activecode" language="java">
            <code>
public class Student {
    public static Integer numStudents = 0;
    private int id;
    private String name;
    public Student(Integer id, String name) {
        this.id = id;
        this.name = name;
        numStudents = numStudents + 1;
    }
    public static void main(String[] args) {
        for(Integer i = 0; i &lt; 10; i++) {
            Student s = new Student(i,"Student"+i.toString());
        }
        System.out.println("Number of students: "+Student.numStudents.toString());
    }
}
            </code> <tests> </tests>
        </program>

        <p>
            <idx>static member variable</idx>
 In this example notice that we create a <term>static member variable</term> by using the <c>static</c> modifier on the variable declaration. Once a variable has been declared <c>static</c> in Java it can be accessed from inside the class without prefixing the name of the class as we had to do in Python. 
        </p>
    </section>

    <section xml:id="static-methods">
        <title>Static Methods</title>

        <p>
 We have already discussed the most common static method of all, <c>main</c>. However in our <c>Fraction</c> class we also implemented a method to calculate the greatest common divisor for two fractions (<c>gdc</c>). There is no reason for this method to be a member method since it takes two <c>Integer</c> values as its parameters. Therefore we declare the method to be a static method of the class. Furthermore, since we are only going to use this <c>gcd</c> method for our own purposes we can make it <c>private</c>. 
        </p>


        <program language="java">
            <code>
private static Integer gcd(Integer m, Integer n) {
    while (m % n != 0) {
        Integer oldm = m;
        Integer oldn = n;
        m = oldn;
        n = oldm%oldn;
    }
    return n;
}
            </code>
        </program>
    </section>

    <section xml:id="full-implementation-of-the-fraction-class">
        <title>Full Implementation of the Fraction Class</title>

        <p>
            Here is a final version of the <c>Fraction</c> class in Java, which includes all the features we discussed:
        </p>


        <program interactive="activecode" language="java">
            <code>
import java.util.ArrayList;
import java.util.Collections;
public class Fraction extends Number implements Comparable&lt;Fraction&gt; {
    private Integer numerator;
    private Integer denominator;
    /** Creates a new instance of Fraction */
    public Fraction(Integer num, Integer den) {
        this.numerator = num;
        this.denominator = den;
    }
    public Fraction(Integer num) {
        this.numerator = num;
        this.denominator = 1;
    }
    public Fraction add(Fraction other) {
        Integer newNum = other.getDenominator()*this.numerator + this.denominator*other.getNumerator();
        Integer newDen = this.denominator * other.getDenominator();
        Integer common = gcd(newNum,newDen);
        return new Fraction(newNum/common, newDen/common);
    }
    public Fraction add(Integer other) {
        return add(new Fraction(other));
    }
    public Integer getNumerator() {
        return numerator;
    }
    public void setNumerator(Integer numerator) {
        this.numerator = numerator;
    }
    public Integer getDenominator() {
        return denominator;
    }
    public void setDenominator(Integer denominator) {
        this.denominator = denominator;
    }
    public String toString() {
        return numerator.toString() + "/" + denominator.toString();
    }
    public boolean equals(Fraction other) {
        Integer num1 = this.numerator * other.getDenominator();
        Integer num2 = this.denominator * other.getNumerator();
        if (num1 == num2)
            return true;
        else
            return false;
    }
    public double doubleValue() {
        return numerator.doubleValue() / denominator.doubleValue();
    }
    public float floatValue() {
        return numerator.floatValue() / denominator.floatValue();
    }
    public int intValue() {
        return numerator.intValue() / denominator.intValue();
    }
    public long longValue() {
        return numerator.longValue() / denominator.longValue();
    }
    public int compareTo(Fraction other) {
        Integer num1 = this.numerator * other.getDenominator();
        Integer num2 = this.denominator * other.getNumerator();
        return num1 - num2;
    }
    private static Integer gcd(Integer m, Integer n) {
        while (m % n != 0) {
            Integer oldm = m;
            Integer oldn = n;
            m = oldn;
            n = oldm%oldn;
        }
        return n;
    }
    public static void main(String[] args) {
        Fraction f1 = new Fraction(1,2);
        Fraction f2 = new Fraction(2,3);
        Fraction f3 = new Fraction(1,4);
        System.out.println("Adding: " + f1.add(1));
        System.out.println("Calling intValue(): " + f1.intValue());
        System.out.println("Calling doubleValue(): " + f1.doubleValue());
        ArrayList&lt;Fraction&gt; myFracs = new ArrayList&lt;Fraction&gt;();
        myFracs.add(f1);
        myFracs.add(f2);
        myFracs.add(f3);
        Collections.sort(myFracs);
        System.out.println("Sorted fractions:");
        for(Fraction f : myFracs) {
            System.out.println(f);
        }
    }
}
            </code> <tests> </tests>
        </program>
    </section>
    
<section xml:id="java_classes_summary">
    <title>Summary &amp; Reading Questions</title>
    <p><ol>
        <li>
            <p>In Java, instance variables (fields) must be declared in the class body before they are used. Unlike Python, you cannot dynamically add new instance variables to an object at runtime.</p>
        </li>
        <li>
            <p>Java uses access modifiers like <c>private</c> to enforce encapsulation, encouraging data hiding and controlled access through getter and setter methods.</p>
        </li>
        <li>
            <p>Java requires a constructor method to initialize objects. A constructor has the same name as the class and defines its parameters explicitly, whereas Python uses the <c>__init__</c> method.</p>
        </li>
        <li>
            <p>Every Java class inherits from the <c>Object</c> class, which provides default methods like <c>toString()</c> and <c>equals()</c>. Overriding <c>toString()</c> gives more meaningful output when printing objects (similar to Python’s <c>__str__</c>).</p>
        </li>
        <li>
            <p>By default, Java’s <c>equals()</c> method checks reference equality, just like <c>==</c> for objects. To compare objects based on content (like <c>Fraction</c> values), you must override <c>equals()</c> and call it explicitly.</p>
        </li>
        <li>
            <p>Java supports inheritance through abstract classes (like <c>Number</c>) and interfaces. Extending an abstract class requires implementing its abstract methods, allowing objects like <c>Fraction</c> to be used where a <c>Number</c> is expected.</p>
        </li>
    </ol></p>

    <reading-questions xml:id="rqs-summary6">
        
        <exercise label="summary-instance-variables">
        <statement>
            <p>How are instance variables declared in Java compared to Python?</p>
        </statement>
        <choices>
            <choice>
            <statement><p>They can be created dynamically anywhere in the class like Python.</p></statement>
            <feedback><p>No, Java does not allow dynamic creation of instance variables at runtime.</p></feedback>
            </choice>
            <choice>
            <statement><p>Instance variables are declared inside methods only.</p></statement>
            <feedback><p>No, instance variables are declared in the class body, not in methods.</p></feedback>
            </choice>
            <choice correct="yes">
            <statement><p>They must be declared in the class body before use.</p></statement>
            <feedback><p>Correct! Java requires instance variables (fields) to be declared in the class body.</p></feedback>
            </choice>
            <choice>
            <statement><p>Java does not use instance variables.</p></statement>
            <feedback><p>No, instance variables are fundamental in Java classes.</p></feedback>
            </choice>
        </choices>
        </exercise>

        <exercise label="summary-encapsulation">
        <statement>
            <p>What Java feature encourages encapsulation and controlled access to instance variables?</p>
        </statement>
        <choices>
            <choice>
            <statement><p>Declaring all variables as public.</p></statement>
            <feedback><p>No, that would expose data and reduce encapsulation.</p></feedback>
            </choice>
            <choice correct="yes">
            <statement><p>Using access modifiers like <c>private</c> and providing getter/setter methods.</p></statement>
            <feedback><p>Right! This is how Java enforces encapsulation.</p></feedback>
            </choice>
            <choice>
            <statement><p>Using global variables.</p></statement>
            <feedback><p>No, Java does not support global variables and this reduces encapsulation.</p></feedback>
            </choice>
            <choice>
            <statement><p>Avoiding the use of classes altogether.</p></statement>
            <feedback><p>No, encapsulation is a class-based concept in Java.</p></feedback>
            </choice>
        </choices>
        </exercise>

        <exercise label="summary-constructor">
        <statement>
            <p>How does Java initialize objects differently than Python?</p>
        </statement>
        <choices>
            <choice correct="yes">
            <statement><p>Java uses a constructor method named after the class with explicit parameters.</p></statement>
            <feedback><p>Correct! Unlike Python's <c>__init__</c>, Java constructors share the class name.</p></feedback>
            </choice>
            <choice>
            <statement><p>Java uses the <c>__init__</c> method like Python.</p></statement>
            <feedback><p>No, Java does not have <c>__init__</c>.</p></feedback>
            </choice>
            <choice>
            <statement><p>Java initializes objects automatically without constructors.</p></statement>
            <feedback><p>No, Java requires constructors for explicit initialization.</p></feedback>
            </choice>
            <choice>
            <statement><p>Java uses global initialization functions instead of constructors.</p></statement>
            <feedback><p>No, Java uses constructors, not global functions, for object initialization.</p></feedback>
            </choice>
        </choices>
        </exercise>

        <exercise label="summary-tostring-equals">
        <statement>
            <p>What must you do in Java to print objects in a readable way and compare two objects based on their contents rather than their memory references?</p>
        </statement>
        <choices>
            <choice>
            <statement><p>Use <c>==</c> for content comparison and no need to override <c>toString()</c>.</p></statement>
            <feedback><p>No, <c>==</c> compares memory references, not content.</p></feedback>
            </choice>
            <choice>
            <statement><p>Only override <c>toString()</c> and use <c>==</c> for equality.</p></statement>
            <feedback><p>No, you should override <c>equals()</c> to compare content correctly.</p></feedback>
            </choice>
            <choice>
            <statement><p>Java automatically handles content comparison without overrides.</p></statement>
            <feedback><p>No, default <c>equals()</c> compares references, not content.</p></feedback>
            </choice>
            <choice correct="yes">
            <statement><p>Override <c>toString()</c> for printing and override <c>equals()</c> to compare object contents.</p></statement>
            <feedback><p>Yes! This improves output and content-based comparison.</p></feedback>
            </choice>
        </choices>
        </exercise>

    </reading-questions>
</section>


</chapter>