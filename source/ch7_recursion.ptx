<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="recursion-in-java">
    <title>Recursion in Java</title>
    <introduction>
    </introduction>

<section xml:id="basic-recursion">
        <title>Basic Recursion</title>
        <p>
            In this chapter, we will explore how to translate your recursive logic from Python to Java. While the core concepts of recursion remain the same, the syntax and structure of your code will change somewhat.
        </p>
        <p><idx>recursion</idx>
            As you may know from Python, <term>recursion</term> is a powerful problem-solving technique involving base cases and recursive steps in which a function or method calls itself. When moving to Java, the core logic you've learned remains identical. The challenge is adapting that logic to Java's statically-typed, class-based syntax.
        </p>

<p>
    Let's take the familiar factorial function, which calculates <m>n!</m> (read as "n factorial"), so for example 5! = 5 × 4 × 3 × 2 × 1 = 120. Factorial is a classic example of recursion, where the function calls itself with a smaller value until it reaches a base case. 
    In general, <m>n! = n \times (n-1) \times (n-2) \times \cdots \times 2 \times 1</m>, 
    or recursively defined as <m>n! = n \times (n-1)!</m> with base cases <m>0! = 1</m> and <m>1! = 1</m>.
</p>
<p>
    You may recall mathematical notation using the symbol <m>\sum</m> (Greek letter sigma) 
    to represent "sum." For example, when we sum all elements in an array, we write 
    <m>\sum_{i=0}^{n-1} a_i</m>, where <m>i=0</m> below the symbol indicates we start at index 0, 
    <m>n-1</m> above it means we end at index <m>n-1</m>, and <m>a_i</m> represents the array 
    element at each index <m>i</m>. Similarly, <m>\sum_{i=1}^{n} i</m> means "sum all integers 
    <m>i</m> from 1 to <m>n</m>."
</p>
<p>
    Factorial involves multiplication rather than addition, so we use the product symbol 
    <m>\prod</m> (Greek letter pi): <m>n! = \prod_{i=1}^{n} i</m>, which means "multiply 
    all integers <m>i</m> from 1 to <m>n</m>." Both summation and factorial can be expressed 
    recursively—summation as the first element plus the sum of remaining elements, and factorial 
    as <m>n \times (n-1)!</m>.
</p>
        <p>
            Here is a Python implementation of factorial using functions:
        </p>
        <program xml:id="factorial-python-function" interactive="activecode" language="python">
            <code>
def factorial(n):
    # Check for negative numbers
    if n &lt; 0:
        print("Factorials are only defined on non-negative integers.")
        return
    # Base Case: 0! or 1! is 1
    if n &lt;= 1:
        return 1
    # Recursive Step: n * (n-1)!
    return n * factorial(n - 1)

def main():
    number = 5
    print(str(number) + "! is " + str(factorial(number)))

main()
            </code>
        </program>
        
        <p>
            Many Python programs organize related functions into classes. The same factorial function can be placed inside a class as a method. Then you need to create an instance of the class to call the method. There we create the class <c>MathTools</c> with a method <c>factorial</c>, and we call it from the <c>main</c> function.
        </p>
        <program xml:id="factorial-python-class" interactive="activecode" language="python">
            <code>
class MathTools:
    def factorial(self, n):
        # Check for negative numbers
        if n &lt; 0:
            print("Factorials are only defined on non-negative integers.")
            return
        # Base Case: 0! or 1! is 1
        if n &lt;= 1:
            return 1
        # Recursive Step: n * (n-1)!
        return n * self.factorial(n - 1)

def main():
    # Create an instance of the class and call the method
    math_tools = MathTools()
    number = 5
    print(str(number) + "! is " + str(math_tools.factorial(number)))

main()
            </code>
        </program>
        
        <p>
           See if you can spot the differences in the Java version below.
        </p>
        <p>
            Here is the equivalent Java code:
        </p>
        <program xml:id="factorial-java-class" interactive="activecode" language="java">
            <code>
public class MathTools {
    public static int factorial(int n) {
        // Check for negative numbers
        if (n &lt; 0) {
            System.out.println("Factorials are only defined on non-negative integers.");
            return -1;  // Return -1 to indicate error
        }
        // Base Case: 0! or 1! is 1
        if (n &lt;= 1) {
            return 1;
        }
        // Recursive Step: n * (n-1)!
        return n * factorial(n - 1);
    }

    public static void main(String[] args) {
        int number = 5;
        System.out.println(number + "! is " + factorial(number));
    }
}
            </code>
        </program>
        <p>
           Notice the key differences from Python: instead of <c>def factorial(n):</c>, Java uses <c>public static int factorial(int n)</c> which declares the method's visibility as <c>public</c>, that it belongs to the class rather than an instance (hence, <c>static</c>), the return type as integer, and the parameter type also as integer. The recursive logic—base case and recursive step—remains identical to Python, but all code blocks use curly braces <c>{}</c> instead of indentation.
        </p>
    </section>

<section xml:id="using-helper-methods">
    <title>Using Helper Methods</title>

    <p>
        In many recursive algorithms, the recursive calls need extra information that the original caller shouldn't have to provide. For example, to recursively process an array, you need to keep track of the index of the current position. This extra information clutters the public-facing signature by forcing users to provide implementation details they shouldn't actually need to know about.
    </p>
    <p><idx>helper method pattern in recursion</idx>
        A common pattern to solve this problem is by using a <term>helper method</term>. This pattern lets you create a clean, simple function or public method that users can call, while the private helper function or method handles the complex details of the recursion. The function or public method typically makes an initial call to the private helper method or function, providing the necessary starting values for the extra parameters.
    </p>

    
    <p>
        First, let's see what happens if we try to write a recursive array sum function <em>without</em> using a helper method. In this approach, the user must provide the starting index, which is awkward and exposes implementation details:
    </p>
    <program xml:id="array-sum-python-no-helper" interactive="activecode" language="python">
        <code>
class ArrayProcessor:
    def sum_array(self, arr, index):
        """
        This version forces users to provide the index parameter.
        This is inconvenient and exposes implementation details.
        """
        # Base case: we've processed all elements
        if index &gt;= len(arr):
            return 0
        
        # Recursive step: current element + sum of remaining elements
        return arr[index] + self.sum_array(arr, index + 1)

def main():
    processor = ArrayProcessor()
    numbers = [1, 2, 3, 4, 5]
    # Users must remember to start at index 0 - this is confusing!
    result = processor.sum_array(numbers, 0)
    print("The sum of " + str(numbers) + " is " + str(result))

main()
        </code>
    </program>
    
    <p>
        This approach has a significant problem, namely that users must remember to start with index 0. Hence, the method signature is cluttered with an implementation detail, and it's easy to make a mistake by passing the wrong starting index. The same awkward pattern appears in Java:
    </p>
    <program xml:id="array-sum-java-no-helper" interactive="activecode" language="java">
        <code>
public class ArrayProcessor {
    public static int sumArray(int[] arr, int index) {
        // Base case: we've processed all elements
        if (index &gt;= arr.length) {
            return 0;
        }
        
        // Recursive step: current element + sum of remaining elements
        return arr[index] + sumArray(arr, index + 1);
    }
    
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};
        // Users must remember to start at index 0 - this is confusing!
        int result = sumArray(numbers, 0);
        System.out.println("The sum of [1, 2, 3, 4, 5] is " + result);
    }
}
        </code>
    </program>
    
    <p>
        Both versions force users to understand and provide implementation details they shouldn't need to know about. Now let's see how helper methods solve this problem by providing a clean, user-friendly interface. Notice how the public method only requires the array itself, and the hidden recursive logic tracks the current index position.
    </p>
    <p>
        Here's the improved Python version using a helper method:
    </p>
    <program xml:id="array-sum-python-with-helper" interactive="activecode" language="python">
        <code>
class ArrayProcessor:
    def sum_array(self, arr):
        """
        Public method that provides a clean interface for summing array elements.
        Users only need to provide the array - no implementation details required.
        """
        if not arr:  # Handle empty array
            return 0
        # Start the recursion at index 0
        return self._sum_helper(arr, 0)
    
    def _sum_helper(self, arr, index):
        """
        Private helper method that does the actual recursive work.
        Tracks the current index position through the array.
        """
        # Base case: we've processed all elements
        if index &gt;= len(arr):
            return 0
        
        # Recursive step: current element + sum of remaining elements
        return arr[index] + self._sum_helper(arr, index + 1)

def main():
    processor = ArrayProcessor()
    numbers = [1, 2, 3, 4, 5]
    result = processor.sum_array(numbers)
    print("The sum of " + str(numbers) + " is " + str(result))

main()
        </code>
    </program>
    
    <p><idx>separation of concerns</idx>
        The key insight here is called the <term>separation of concerns</term>. The public <c>sum_array</c> method provides a user-friendly interface—callers just pass an array and get the sum. Users don't need to know about indexes or how the recursion works internally. The private <c>_sum_helper</c> method handles the recursive logic with the extra parameter needed to track progress through the array.
    </p>
    
    <p>
        Now let's see the improved Java version using a helper method:
    </p>
    <program xml:id="array-sum-java-with-helper" interactive="activecode" language="java">
        <code>
public class ArrayProcessor {
    public static int sumArray(int[] arr) {
        // Handle empty array
        if (arr.length == 0) {
            return 0;
        }
        // Start the recursion at index 0
        return sumHelper(arr, 0);
    }
    
    private static int sumHelper(int[] arr, int index) {
        // Base case: we've processed all elements
        if (index &gt;= arr.length) {
            return 0;
        }
        
        // Recursive step: current element + sum of remaining elements
        return arr[index] + sumHelper(arr, index + 1);
    }
    
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};
        int result = sumArray(numbers);
        System.out.println("The sum of [1, 2, 3, 4, 5] is " + result);
    }
}
        </code>
    </program>
    
    <p>
        Compare these improved versions with the earlier problematic ones. Notice how much cleaner the method calls become: <c>processor.sum_array(numbers)</c> in Python and <c>sumArray(numbers)</c> in Java. Users no longer need to worry about providing the correct starting index or understanding the internal mechanics of the recursion. The helper method pattern creates a clear separation between what users need to know (just pass an array) and the implementation details (tracking the index through recursion).
    </p>
    
    <p>
        This helper method pattern is essential when your recursive algorithm needs to track additional state (like array positions, accumulated values, or depth counters) that the original caller shouldn't need to provide or care about. It's a fundamental pattern and technique you'll likely use frequently in recursive problem solving.
    </p>
</section>

    <section xml:id="recursion-limits-in-java">
        <title>Recursion Limits: Python vs. Java</title>
        <p>
            The consequence of deep recursion, running out of stack space, is a concept you've already encountered in Python. Java handles this in a very similar way, throwing an error when the call stack depth is exceeded.
        </p>
        <p>
            The key difference is the name of the error:
        </p>
        <ul>
            <li>In Python, this raises a <c>RecursionError</c>.</li>
            <li>In Java, this throws a <c>StackOverflowError</c>.</li>
        </ul>
        <p>
            Neither language supports <idx> tail call optimization </idx><term>tail call optimization</term>, so the practical limits on recursion depth are a factor in both. If an algorithm requires thousands of recursive calls, an iterative (loop-based) approach is the preferred solution in both Python and Java.
        </p>
        <p>
            The following Python code demonstrates a situation where a function calls itself indefinitely without a base case, leading to aRecursionError.
        </p>
        <program xml:id="python-recursion-error" interactive="activecode" language="python">
            <code>
                def cause_recursion_error():
                    """
                    This function calls itself without a base case, guaranteeing an error.
                    """
                    cause_recursion_error()

                # Standard Python entry point
                if __name__ == "__main__":
                    print("Calling the recursive function... this will end in an error!")
                    
                    # This line starts the infinite recursion.
                    # Python will stop it and raise a RecursionError automatically.
                    cause_recursion_error()
            </code>
        </program>

        <p>
            The following Java code demonstrates a similar situation, where a method calls itself indefinitely without a base case, leading to a StackOverflowError.
        </p>
        <program xml:id="java-stack-overflow" interactive="activecode" language="java">
            <code>
                public class Crash {
                    public static void causeStackOverflow() {
                        // This method calls itself endlessly without a stopping condition (a base case).
                        // Each call adds a new layer to the program's call stack.
                        // Eventually, the stack runs out of space, causing the error.
                        causeStackOverflow();
                    }
                    // A main method is required to run the program.
                    public static void main(String[] args) {
                        System.out.println("Calling the recursive method... this will end in an error!");
                        // This line starts the infinite recursion.
                        causeStackOverflow();
                    }
                }
            </code>
        </program>
    </section>
</chapter>