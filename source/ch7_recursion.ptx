<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="recursion-in-java">
    <title>Recursion in Java</title>
    <introduction>
    </introduction>

<section xml:id="basic-recursion">
        <title>Basic Recursion</title>
        <p>
            In this chapter, we will explore how to translate your recursive logic from Python to Java. While the core concepts of recursion remain the same, the syntax and a bit of the structure of your code will change somewhat.
        </p>
        <p><idx>recursion</idx><idx>base case</idx><idx>recursive step</idx>
            As you may know from Python, <term>recursion</term> is a powerful problem-solving technique involving one or more <term>base cases</term> and <term>recursive steps</term> in which a function or method calls itself while moving towards a base case. When moving to Java, the core logic you've learned remains identical. The challenge is adapting that logic to Java's statically-typed, class-based syntax.
        </p>

<p>
    Let's take the familiar factorial function, which calculates <m>n!</m> (read as "n factorial"), so for example 5! = 5 × 4 × 3 × 2 × 1 = 120. Factorial is a classic example of recursion, where the function calls itself with a smaller value until it reaches a base case. 
    In general, <m>n! = n \times (n-1) \times (n-2) \times \cdots \times 2 \times 1</m>, 
    or recursively defined as <m>n! = n \times (n-1)!</m> with base cases <m>0! = 1</m> and <m>1! = 1</m>.
</p>
<p>
    You may recall mathematical notation using the symbol <m>\sum</m> (Greek letter sigma) 
    to represent "sum." For example, when we sum all elements in an array, we write 
    <m>\sum_{i=0}^{n-1} a_i</m>, where <m>i=0</m> below the symbol indicates we start at index 0, 
    <m>n-1</m> above it means we end at index <m>n-1</m>, and <m>a_i</m> represents the array 
    element at each index <m>i</m>. Similarly, <m>\sum_{i=1}^{n} i</m> means "sum all integers 
    <m>i</m> from 1 to <m>n</m>."
</p>
<p>
    Factorial involves multiplication rather than addition, so we use the product symbol 
    <m>\prod</m> (Greek letter pi): <m>n! = \prod_{i=1}^{n} i</m>, which means "multiply 
    all integers <m>i</m> from 1 to <m>n</m>." Both summation and factorial can be expressed 
    recursively—summation as the first element plus the sum of remaining elements, and factorial 
    as <m>n \times (n-1)!</m>.
</p>
        <p>
            Here is a Python implementation of factorial using just one function:
        </p>
        <program xml:id="factorial-python-function" interactive="activecode" language="python">
            <code>
def factorial(n):
    # Check for negative numbers
    if n &lt; 0:
        print("Factorials are only defined on non-negative integers.")
        return
    # Base Case: 0! or 1! is 1
    if n &lt;= 1:
        return 1
    # Recursive Step: n * (n-1)!
    return n * factorial(n - 1)

number = 5
print(str(number) + "! is " + str(factorial(number)))

     </code>
        </program>
        
        <p>
            Many Python programs organize related functions into classes. The same factorial function can be placed inside a class as a method instead of as a function. When this is done, you need to create an instance of the class in order to call the method. Below, we create the class <c>MathTools</c> with a method <c>factorial</c>, and we call it from the <c>main</c> function.
        </p>
        <program xml:id="factorial-python-class" interactive="activecode" language="python">
            <code>
class MTools:
    def factorial(self, n):
        # Check for negative numbers
        if n &lt; 0:
            print("Factorials are only defined on non-negative integers.")
            return
        # Base Case: 0! or 1! is 1
        if n &lt;= 1:
            return 1
        # Recursive Step: n * (n-1)!
        return n * self.factorial(n - 1)

def main():
    # Create an instance of the class and call the method
    mtools_instance = MTools()
    number = 5
    print(str(number) + "! is " + str(mtools_instance.factorial(number)))

main()
            </code>
        </program>
        
        <p>
           See if you can spot the differences in the Java version below.
        </p>
        <p>
            Here is the equivalent Java code:
        </p>
        <program xml:id="factorial-java-class" interactive="activecode" language="java">
            <code>
public class MTools {
    public static int factorial(int n) {
        // Check for negative numbers
        if (n &lt; 0) {
            System.out.println("Factorials are only defined on non-negative integers.");
            return -1;  // Return -1 to indicate error
        }
        // Base Case: 0! or 1! is 1
        if (n &lt;= 1) {
            return 1;
        }
        // Recursive Step: n * (n-1)!
        return n * factorial(n - 1);
    }

    public static void main(String[] args) {
        int number = 5;
        System.out.println(number + "! is " + factorial(number));
    }
}
            </code>
        </program>
        <p>
           Notice the key differences from Python: instead of <c>def factorial(n):</c>, Java uses <c>public static int factorial(int n)</c> which declares the method's visibility as <c>public</c>, that it belongs to the class rather than an instance (hence, <c>static</c>), the return type as integer, and the parameter type also as integer. The recursive logic—base case and recursive step—remains identical to Python, and, of course, all code blocks use curly braces <c>{}</c> instead of indentation.
        </p>
    </section>

<section xml:id="using-helper-methods">
    <title>Using Helper Methods</title>

    <p>
        In many recursive algorithms, the recursive calls need extra information that the original caller shouldn't have to provide. For example, to recursively process an array, you need to keep track of the index of the current position. This extra information clutters the public-facing signature by forcing users to provide implementation details they shouldn't actually need to know about.
    </p>
    <p><idx>helper method pattern in recursion</idx>
        A common pattern to solve this problem is by using a <term>helper method</term>. This pattern lets you create a clean, simple function or public method that users can call, while the private helper function or method handles the complex details of the recursion. The function or public method typically makes an initial call to the private helper method or function, providing the necessary starting values for the extra parameters.
    </p>

    
    <p>
        First, let's see what happens if we try to write a recursive array sum function <em>without</em> using a helper method. In this approach, the user must provide the starting index, which is awkward and exposes implementation details:
    </p>
    <program xml:id="array-sum-python-no-helper" interactive="activecode" language="python">
        <code>
class ArrayProcessor:
    def sum_array(self, arr, index):
        """
        This version forces users to provide the index parameter.
        This is inconvenient and exposes implementation details.
        """
        # Base case: we've processed all elements
        if index &gt;= len(arr):
            return 0
        
        # Recursive step: current element + sum of remaining elements
        return arr[index] + self.sum_array(arr, index + 1)

def main():
    processor = ArrayProcessor()
    numbers = [1, 2, 3, 4, 5]
    # Users must remember to start at index 0 - this is confusing!
    result = processor.sum_array(numbers, 0)
    print("The sum of " + str(numbers) + " is " + str(result))

main()
        </code>
    </program>
    
    <p>
        This approach has a significant problem, namely that users must remember to start with index 0. Hence, the method signature is cluttered with an implementation detail, and it's easy to make a mistake by passing the wrong starting index. The same awkward pattern appears in Java:
    </p>
    <program xml:id="array-sum-java-no-helper" interactive="activecode" language="java">
        <code>
public class ArrayProcessor {
    public static int sumArray(int[] arr, int index) {
        // Base case: we've processed all elements
        if (index &gt;= arr.length) {
            return 0;
        }
        
        // Recursive step: current element + sum of remaining elements
        return arr[index] + sumArray(arr, index + 1);
    }
    
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};
        // Users must remember to start at index 0 - this is confusing!
        int result = sumArray(numbers, 0);
        System.out.println("The sum of [1, 2, 3, 4, 5] is " + result);
    }
}
        </code>
    </program>
    
    <p>
        Both versions force users to understand and provide implementation details they shouldn't need to know about. Now let's see how helper methods solve this problem by providing a clean, user-friendly interface. Notice how the public method only requires the array itself, and the hidden recursive logic tracks the current index position.
    </p>
    <p>
        Here's the improved Python version using a helper method:
    </p>
    <program xml:id="array-sum-python-with-helper" interactive="activecode" language="python">
        <code>
class ArrayProcessor:
    def sum_array(self, arr):
        """
        Public method that provides a clean interface for summing array elements.
        Users only need to provide the array - no implementation details required.
        """
        if not arr:  # Handle empty array
            return 0
        # Start the recursion at index 0
        return self._sum_helper(arr, 0)
    
    def _sum_helper(self, arr, index):
        """
        Private helper method that does the actual recursive work.
        Tracks the current index position through the array.
        """
        # Base case: we've processed all elements
        if index &gt;= len(arr):
            return 0
        
        # Recursive step: current element + sum of remaining elements
        return arr[index] + self._sum_helper(arr, index + 1)

def main():
    processor = ArrayProcessor()
    numbers = [1, 2, 3, 4, 5]
    result = processor.sum_array(numbers)
    print("The sum of " + str(numbers) + " is " + str(result))

main()
        </code>
    </program>
    
    <p><idx>separation of concerns</idx>
        The key insight here is called the <term>separation of concerns</term>. The public <c>sum_array</c> method provides a user-friendly interface—callers just pass an array and get the sum. Users don't need to know about indexes or how the recursion works internally. The private <c>_sum_helper</c> method handles the recursive logic with the extra parameter needed to track progress through the array.
    </p>
    
    <p>
        Now let's see the improved Java version using a helper method:
    </p>
    <program xml:id="array-sum-java-with-helper" interactive="activecode" language="java">
        <code>
public class ArrayProcessor {
    public static int sumArray(int[] arr) {
        // Handle empty array
        if (arr.length == 0) {
            return 0;
        }
        // Start the recursion at index 0
        return sumHelper(arr, 0);
    }
    
    private static int sumHelper(int[] arr, int index) {
        // Base case: we've processed all elements
        if (index &gt;= arr.length) {
            return 0;
        }
        
        // Recursive step: current element + sum of remaining elements
        return arr[index] + sumHelper(arr, index + 1);
    }
    
    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5};
        int result = sumArray(numbers);
        System.out.println("The sum of " + Arrays.toString(numbers) + " is " + result);
    }
}
        </code>
    </program>
    
    <p>
        Compare these improved versions with the earlier problematic ones. Notice how much cleaner the method calls become: <c>processor.sum_array(numbers)</c> in Python and <c>sumArray(numbers)</c> in Java. Users no longer need to worry about providing the correct starting index or understanding the internal mechanics of the recursion. The helper method pattern creates a clear separation between what users need to know (just pass an array) and the implementation details (tracking the index through recursion).
    </p>
    
    <p>
        This helper method pattern is essential when your recursive algorithm needs to track additional state (like array positions, accumulated values, or depth counters) that the original caller shouldn't need to provide or care about. It's a fundamental pattern and technique you'll likely use frequently in recursive problem solving.
    </p>
</section>

    <section xml:id="recursion-limits-in-java">
        <title>Recursion Limits: Python vs. Java</title>
        <p>
            The consequence of deep recursion, running out of stack space, is a concept you may have already encountered in Python. Java handles this in a very similar way to Python, throwing an error when the call stack depth is exceeded.
        </p>
        <p>
            The key difference is the name of the error:
        </p>
        <ul>
            <li>In Python, this raises a <c>RecursionError</c>.</li>
            <li>In Java, this throws a <c>StackOverflowError</c>.</li>
        </ul>
        <p>
            Neither language supports <idx> tail call optimization </idx><term>tail call optimization</term>, so the practical limits on recursion depth are a factor in both. If an algorithm requires thousands of recursive calls, an iterative, loop-based, approach is likely going to be the preferred solution in both Python and Java.
        </p>
        <p>
            The following Python code demonstrates a situation where a function calls itself indefinitely without a base case, leading to a <c>RecursionError</c>.
        </p>
        <program xml:id="python-recursion-error" interactive="activecode" language="python">
            <code>
                def cause_recursion_error():
                    """
                    This function calls itself without a base case, guaranteeing an error.
                    """
                    cause_recursion_error()

                print("Calling the recursive function... this will end in an error!")

                # The line below will start the infinite recursion.
                # Python will stop it and raise a RecursionError automatically.
                # Each call adds a new layer to the program's call stack.
                # Eventually, the call stack runs out of space, causing the error.
                cause_recursion_error()
            </code>
        </program>

        <p>
            The following Java code demonstrates a similar situation, where a method calls itself indefinitely without a base case, leading to a <c>StackOverflowError</c>.
        </p>
        <program xml:id="java-stack-overflow" interactive="activecode" language="java">
            <code>
                public class Crash {
                    public static void causeStackOverflow() {
                    // The line below will start the infinite recursion.
                    // Java will stop it and raise a StackOverflowError automatically.
                    // Each call adds a new layer to the program's call stack.
                    // Eventually, the call stack runs out of space, causing the error.
                        causeStackOverflow();
                    }
                    // A main method is required to run the Java program.
                    public static void main(String[] args) {
                        System.out.println("Calling the recursive method... this will end in an error!");

                        causeStackOverflow();
                    }
                }
            </code>
        </program>
    </section>

    <section xml:id="recursion_java_summary">
    <title>Summary &amp; Reading Questions</title>
    <p><ol label="1">
        <li>
            <p>Recursion solves problems by defining a <em>base case</em> and a <em>recursive step</em>; each call reduces the problem size until the base case is reached.</p>
        </li>
        <li>
            <p>Java methods must declare visibility, static/instance context, return type, and parameter types; e.g., <c>public static int factorial(int n)</c>.</p>
        </li>
        <li>
            <p>The recursive logic in Java mirrors Python conceptually, but Java uses curly braces <c>{}</c> and explicit types instead of indentation and dynamic typing.</p>
        </li>
        <li>
            <p>The helper-method pattern keeps public APIs clean (e.g., <c>sumArray(int[] arr)</c>) while a private helper (e.g., <c>sumHelper(int[] arr, int index)</c>) carries extra state like the current index.</p>
        </li>
        <li>
            <p>Closing over array bounds and indexes in the helper avoids forcing callers to provide implementation details (like a starting index).</p>
        </li>
        <li>
            <p>Deep or unbounded recursion can exhaust the call stack: Python raises <c>RecursionError</c>; Java throws <c>StackOverflowError</c>.</p>
        </li>
        <li>
            <p>Neither Java nor Python guarantees tail call optimization; prefer iterative solutions for algorithms requiring very deep recursion.</p>
        </li>
        <li>
            <p>Error signaling differs across languages; for example, a Java factorial that receives a negative <c>n</c> might return a sentinel value (e.g., <c>-1</c>) after printing an error message.</p>
        </li>
    </ol></p>
    <reading-questions xml:id="rqs-recursion-java">
        <exercise label="recursion-1">
            <statement>
                <p>Which method signature and behavior best match a typical Java recursive factorial implementation?</p>
            </statement>
            <choices>
                <choice>
                    <statement><p><c>public void factorial(int n)</c> that prints each partial product and stops when <c>n</c> reaches zero.</p></statement>
                    <feedback><p>No. Printing results is fine for testing, but a proper factorial method should return the computed value.</p></feedback>
                </choice>
                <choice correct="yes">
                    <statement><p><c>public static int factorial(int n)</c> that returns <c>1</c> when <c>n &lt;= 1</c> and otherwise returns <c>n * factorial(n - 1)</c>.</p></statement>
                    <feedback><p>Correct. This matches the standard recursive factorial definition in Java.</p></feedback>
                </choice>
                <choice>
                    <statement><p><c>private static int factorial(double n)</c> that repeatedly multiplies <c>n</c> and decrements it until it reaches 1.</p></statement>
                    <feedback><p>No. Factorials are for integers, and using <c>double</c> here is unnecessary and can cause rounding issues.</p></feedback>
                </choice>
                <choice>
                    <statement><p><c>public int factorial()</c> that uses a stored class field for <c>n</c> instead of a method parameter.</p></statement>
                    <feedback><p>No. Relying on a class field hides the input and makes recursion less flexible.</p></feedback>
                </choice>
            </choices>
        </exercise>
        <exercise label="recursion-2">
            <statement>
                <p>Why use a private helper method (e.g., <c>sumHelper(int[] arr, int index)</c>) behind a public method (e.g., <c>sumArray(int[] arr)</c>) in recursive array processing?</p>
            </statement>
            <choices>
                <choice>
                    <statement><p>Because it allows Java to automatically optimize the recursion for faster execution.</p></statement>
                    <feedback><p>No. Java does not automatically optimize recursion just because you use a helper method.</p></feedback>
                </choice>
                <choice correct="yes">
                    <statement><p>To keep the public API simple while encapsulating extra recursion state (such as the current index) inside a private method.</p></statement>
                    <feedback><p>Correct. This keeps the interface clean while hiding internal details from the caller.</p></feedback>
                </choice>
                <choice>
                    <statement><p>Because public methods cannot take more than one parameter in recursive calls.</p></statement>
                    <feedback><p>No. Public methods can take multiple parameters; this is about interface clarity, not parameter limits.</p></feedback>
                </choice>
                <choice>
                    <statement><p>To eliminate the need for a base case by handling termination in the helper method automatically.</p></statement>
                    <feedback><p>No. The helper method still needs an explicit base case to stop recursion.</p></feedback>
                </choice>
            </choices>
        </exercise>
        <exercise label="recursion-3">
    <statement>
        <p>Which statement about recursion limits and errors is accurate?</p>
    </statement>
    <choices>
        <choice>
            <statement>
                <p>Java can handle very deep or even infinite recursion if the method body is short and does not perform significant operations.</p>
            </statement>
            <feedback>
                <p>No. Regardless of the method’s complexity, each recursive call consumes stack space, and infinite recursion will always cause a stack overflow.</p>
            </feedback>
        </choice>
        <choice correct="yes">
            <statement>
                <p>When the call stack is exhausted, Python raises a <c>RecursionError</c> whereas Java throws a <c>StackOverflowError</c>, and neither language applies automatic tail call optimization.</p>
            </statement>
            <feedback>
                <p>Correct. This difference in exception types and the lack of built-in tail call optimization is a key distinction between the two languages.</p>
            </feedback>
        </choice>
        <choice>
            <statement>
                <p>Declaring a recursive method as <c>static</c> in Java reduces memory usage per call, allowing more recursive calls before a stack overflow occurs.</p>
            </statement>
            <feedback>
                <p>No. The <c>static</c> modifier changes method context (class vs. instance) but does not meaningfully affect per-call stack memory usage.</p>
            </feedback>
        </choice>
        <choice>
            <statement>
                <p>Increasing a method’s parameter type from <c>int</c> to <c>long</c> in Java can prevent stack overflows for large input values by storing bigger numbers more efficiently.</p>
            </statement>
            <feedback>
                <p>No. The size of the number type does not influence the maximum recursion depth; stack space usage depends on the number of active calls, not numeric range.</p>
            </feedback>
        </choice>
    </choices>
</exercise>
    </reading-questions>
</section>
</chapter>