<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="recursion-in-java">
    <title>Recursion in Java</title>
    <introduction>
    </introduction>
    <section xml:id="basic-recursion">
        <title>Basic Recursion</title>
        <p>
            In this chapter, we will explore how to translate your recursive logic from Python to Java. While the core concepts of recursion remain the same, the syntax and structure of your code will change somewhat.
        </p>
            <p><idx>recursion</idx>
                As you may know from Python, <term>recursion</term> is a powerful problem-solving technique involving base cases and recursive steps in which a function or method calls itself. When moving to Java, the core logic you've learned remains identical. The challenge is adapting that logic to Java's statically-typed, class-based syntax.
            </p>
            <p>
                Let's take the familiar factorial function (which calculates the factorial of a number, namely the product of all positive integers from 1 to n). The logical steps in the code are the same, but the implementation details change.
            </p>
            <p>
                Here is the standard implementation in Python:
            </p>
            <program interactive="activecode" language="python">
                <code>
                class MathTools:
                    """A utility class for mathematical operations."""
                    def factorial(n: int) -&gt; int:
                        """Calculates the factorial of n using recursion."""
                        # A check for negative numbers is good practice.
                        if n &lt; 0:
                            raise ValueError("Factorial is not defined for negative numbers.")        # Base Case: 0! or 1! is 1
                        if n &lt;= 1:
                            return 1        # Recursive Step: n * (n-1)!
                        # The call is now to the method within the class.
                        return n * MathTools.factorial(n - 1)# This block shows how to use the class method.
                if __name__ == "__main__":
                    number = 5
                    result = MathTools.factorial(number)  # Call the method on the class
                    print(f"{number}! is {result}")
                </code>
            </program>
            <p>
               The Java version follows the same recursive logic but requires three key syntax changes: the method must be inside a class, you must declare the parameter and return types (<c>int n</c> and <c>int return</c>), and you use <c>public static</c> to make it callable from <c>main</c>. The base case and recursive step remain conceptually identical.
            </p>
            <p>
                Here is the equivalent Java code:
            </p>
            <program interactive="activecode" language="java">
                <code>
                public class MathTools {    /**
                    * Calculates the factorial of n using recursion.
                    * This is a static method, like Python's @staticmethod.
                    * @param n The non-negative integer.
                    * @return The factorial of n as a long to prevent overflow for larger numbers.
                    */
                    public static int factorial(int n) {
                        // A check for negative numbers is good practice.
                        if (n &lt; 0) {
                            throw new IllegalArgumentException("Factorial is not defined for negative numbers.");
                        }        // Base Case: 0! or 1! is 1
                        if (n &lt;= 1) {
                            return 1;
                        }        // Recursive Step: n * (n-1)!
                        return n * factorial(n - 1);
                    }    /**
                    * The main entry point for the application.
                    * This is the Java equivalent of Python's 'if __name__ == "__main__":'
                    */
                    public static void main(String[] args) {
                        int number = 5;
                        // The static method is called directly on the class.
                        long result = MathTools.factorial(number);        System.out.println(number + "! is " + result);
                    }
                }
                </code>
            </program>
            <p>
                Notice the key differences: instead of <c>def</c>, the method signature <c>public static int</c> declares its scope, that it belongs to the class rather than an object, and that it returns an <c>int</c>. All logic is contained within curly braces <c>{}</c>.
            </p>
    </section>
    <section xml:id="java-patterns-for-recursion">
        <title>Common Recursive Patterns</title>

        <p>
            In many recursive algorithms, the recursive calls need extra information that the original caller shouldn't have to provide. For example, to recursively process an array, you need to keep track of the current position (index). To traverse a tree, you need to know the current node. This extra information clutters the public-facing method signature.
        </p>
        <p>
            A common pattern to solve this is using a private helper method. This pattern lets you create a clean, simple public method that users will call, while the private helper method handles the complex details of the recursion. The public method typically makes the initial call to the private helper, providing the necessary starting values for the extra parameters.
        </p>
        <p>
            Let's see this pattern in action with an example that calculates the sum of all elements in an integer array. The public <c>sum</c> method only takes the array, but the private <c>sumHelper</c> method also takes an index to track its progress through the array.
        </p>
        
        <p>
            You're likely familiar with how some recursive algorithms, like the naive Fibonacci implementation,
            are elegant but inefficient, due to branching recursive calls filling the call stack. A common pattern to solve
            this is using a private helper method. 
            </p>
            <p>
                The following example demonstrates this pattern. The public <c>fib</c> method provides a simple entry point, while the private <c>fibHelper</c> method performs the efficient recursion by carrying its state (the previous two numbers) in its parameters.
            </p>
            <p>
                The following Java code demonstrates a similar pattern.
            </p>

            <program interactive="activecode" language="java">
                <code>
                class TreeNode {
                    int val;
                    TreeNode left;
                    TreeNode right;

                    // Constructor to create a new tree node
                    TreeNode(int val) {
                        this.val = val;
                        this.left = null;
                        this.right = null;
                    }
                }

                public class TreeOperationsWithHelper {

                    
                    public static int getTreeDepthAndInOrderTraversal(TreeNode root) {
                        // Handle the case of an empty tree before calling the helper.
                        if (root == null) {
                            System.out.println("In-order traversal: (empty tree)");
                            return 0; // An empty tree has a depth of 0
                        }
                        System.out.print("In-order traversal: ");
                        // Call the private helper method to perform the recursive traversal and depth calculation.
                        // The helper method will return the depth of the tree.
                        return inOrderTraversalAndDepthHelper(root);
                    }

                    
                    private static int inOrderTraversalAndDepthHelper(TreeNode node) {
                        // Base case: If the node is null, it means we've gone past a leaf,
                        // so it contributes 0 to the depth.
                        if (node == null) {
                            return 0;
                        }

                        // Recursively calculate the depth of the left subtree.
                        // The in-order traversal visits the left child first.
                        int leftDepth = inOrderTraversalAndDepthHelper(node.left);

                        // Perform the "in-order" action for the current node: print its value.
                        // This demonstrates the in-order traversal aspect.
                        System.out.print(node.val + " ");

                        // Recursively calculate the depth of the right subtree.
                        // The in-order traversal visits the right child last.
                        int rightDepth = inOrderTraversalAndDepthHelper(node.right);

                        // The depth of the current subtree is 1 (for the current node itself)
                        // plus the maximum depth found in its left or right subtree.
                        return 1 + Math.max(leftDepth, rightDepth);
                    }

                    public static void main(String[] args) {
                        // --- Example Tree 1 ---
                        //      1
                        //     / \
                        //    2   3
                        //   / \
                        //  4   5
                        TreeNode root1 = new TreeNode(1);
                        root1.left = new TreeNode(2);
                        root1.right = new TreeNode(3);
                        root1.left.left = new TreeNode(4);
                        root1.left.right = new TreeNode(5);

                        System.out.println("--- Tree Operations With Helper Method ---");
                        int depth1 = getTreeDepthAndInOrderTraversal(root1);
                        System.out.println("\nDepth of Tree 1: " + depth1); // Expected In-order: 4 2 5 1 3, Depth: 3

                    }
                }
                </code>
            </program>
            <p>
            This helper method approach is significantly more efficient in terms of time than the classic branching recursion (where <c>fib(n)</c> calls <c>fib(n-1)</c> and <c>fib(n-2)</c>). The branching model has an exponential time complexity of roughly O(2^n) because it re-calculates the same values many times. In contrast, our helper method has a linear time complexity of O(n), as it avoids re-computation by carrying the previous two results (a and b) forward into the next call.
        </p>
        <p>
            However, regarding memory efficiency, the comparison is different. The maximum depth of the call stack for both the naive and the helper method is proportional to n, giving them both a space complexity of O(n). This means that while the helper method is much faster, it is equally vulnerable to a <c>StackOverflowError</c> for very large values of n. Because Java does not perform tail-call optimization, any recursive solution that goes too deep will exhaust the stack memory, regardless of its time efficiency. For true memory efficiency (O(1) space), an iterative loop-based solution is superior.
        </p>
        <p>
            The following Python code demonstrates the same pattern, using a public method to initiate the calculation and a private helper method to perform the recursion.
        </p>
        <program interactive="activecode" language="python">
                <code>
                import math # Used for math.max, though Python's built-in max() is often preferred

                # Define a simple TreeNode class for our binary tree
                class TreeNode:
                    def __init__(self, val=0, left=None, right=None):
                        self.val = val
                        self.left = left
                        self.right = right

                class TreeOperationsWithHelper:
                    
                    def get_tree_depth_and_in_order_traversal(root: 'TreeNode') -&gt; int:
                        # Handle the case of an empty tree before calling the helper.
                        if root is None:
                            print("In-order traversal: (empty tree)")
                            return 0  # An empty tree has a depth of 0

                        print("In-order traversal: ", end="")
                        
                        return TreeOperationsWithHelper._in_order_traversal_and_depth_helper(root)

                    
                    def _in_order_traversal_and_depth_helper(node: 'TreeNode') -&gt; int:

                        if node is None:
                            return 0

                        left_depth = TreeOperationsWithHelper._in_order_traversal_and_depth_helper(node.left)

                        print(node.val, end=" ")

                        right_depth = TreeOperationsWithHelper._in_order_traversal_and_depth_helper(node.right)

                        return 1 + max(left_depth, right_depth) # Using Python's built-in max()

                # Provided Solution class for Pre-order Traversal (translated to Python)
                class Solution:
                    def _preorder_traversal_helper(self, root: 'TreeNode', answer: list[int]):
                        if root is None:
                            return
                        answer.append(root.val)
                        self._preorder_traversal_helper(root.left, answer)
                        self._preorder_traversal_helper(root.right, answer)

                    def preorder_traversal(self, root: 'TreeNode') -&gt; list[int]:
                        answer = []
                        self._preorder_traversal_helper(root, answer)
                        return answer

                # Main execution block (equivalent to Java's main method)
                if __name__ == "__main__":
                    # --- Example Tree 1 ---
                    #      1
                    #     / \
                    #    2   3
                    #   / \
                    #  4   5
                    root1 = TreeNode(1)
                    root1.left = TreeNode(2)
                    root1.right = TreeNode(3)
                    root1.left.left = TreeNode(4)
                    root1.left.right = TreeNode(5)

                    print("--- Tree Operations With Helper Method ---")
                    depth1 = TreeOperationsWithHelper.get_tree_depth_and_in_order_traversal(root1)
                    print(f"\nDepth of Tree 1: {depth1}") # Expected In-order: 4 2 5 1 3, Depth: 3
                </code>
            </program>
    </section>
    <section xml:id="recursion-limits-in-java">
        <title>Recursion Limits: Python vs. Java</title>
        <p>
            The consequence of deep recursion, running out of stack space, is a concept you've already encountered in Python. Java handles this in a very similar way, throwing an error when the call stack depth is exceeded.
        </p>
        <p>
            The key difference is the name of the error:
        </p>
        <ul>
            <li>In Python, this raises a <c>RecursionError</c>.</li>
            <li>In Java, this throws a <c>StackOverflowError</c>.</li>
        </ul>
        <p>
            Neither language supports <idx> tail call optimization </idx><term>tail call optimization</term>, so the practical limits on recursion depth are a factor in both. If an algorithm requires thousands of recursive calls, an iterative (loop-based) approach is the preferred solution in both Python and Java.
        </p>
        <p>
            The following Python code demonstrates a situation where a function calls itself indefinitely without a base case, leading to aRecursionError.
        </p>
        <program interactive="activecode" language="python">
            <code>
                def cause_recursion_error():
                    """
                    This function calls itself without a base case, guaranteeing an error.
                    """
                    cause_recursion_error()

                # Standard Python entry point
                if __name__ == "__main__":
                    print("Calling the recursive function... this will end in an error!")
                    
                    # This line starts the infinite recursion.
                    # Python will stop it and raise a RecursionError automatically.
                    cause_recursion_error()
            </code>
        </program>

        <p>
            The following Java code demonstrates a similar situation, where a method calls itself indefinitely without a base case, leading to a StackOverflowError.
        </p>
        <program interactive="activecode" language="java">
            <code>
                public class Crash {
                    public static void causeStackOverflow() {
                        // This method calls itself endlessly without a stopping condition (a base case).
                        // Each call adds a new layer to the program's call stack.
                        // Eventually, the stack runs out of space, causing the error.
                        causeStackOverflow();
                    }
                    // A main method is required to run the program.
                    public static void main(String[] args) {
                        System.out.println("Calling the recursive method... this will end in an error!");
                        // This line starts the infinite recursion.
                        causeStackOverflow();
                    }
                }
            </code>
        </program>
    </section>
</chapter>