<?xml version="1.0" encoding="UTF-8"?>
<chapter xml:id="recursion-in-java">
    <title>Recursion in Java</title>
    <introduction>
    </introduction>

<section xml:id="basic-recursion">
        <title>Basic Recursion</title>
        <p>
            In this chapter, we will explore how to translate your recursive logic from Python to Java. While the core concepts of recursion remain the same, the syntax and structure of your code will change somewhat.
        </p>
        <p><idx>recursion</idx>
            As you may know from Python, <term>recursion</term> is a powerful problem-solving technique involving base cases and recursive steps in which a function or method calls itself. When moving to Java, the core logic you've learned remains identical. The challenge is adapting that logic to Java's statically-typed, class-based syntax.
        </p>
        <p>
            Let's take the familiar factorial function (which calculates the factorial of a number, namely the product of all positive integers from 1 to n). The logical steps in the code are the same, but the implementation details change.
        </p>
        <p>
            Here is a simple Python function implementation:
        </p>
        <program interactive="activecode" language="python">
            <code>
def factorial(n):
    # Check for negative numbers
    if n &lt; 0:
        print("Factorials are only defined on non-negative integers.")
        return
    # Base Case: 0! or 1! is 1
    if n &lt;= 1:
        return 1
    # Recursive Step: n * (n-1)!
    return n * factorial(n - 1)

def main():
    number = 5
    print(str(number) + "! is " + str(factorial(number)))

main()
            </code>
        </program>
        
        <p>
            Many Python programs organize related functions into classes. The same factorial function can be placed inside a class as a method. Then you need to create an instance of the class to call the method. There we create the class <c>MathTools</c> with a method <c>factorial</c>, and we call it from the <c>main</c> function.
        </p>
        <program interactive="activecode" language="python">
            <code>
class MathTools:
    def factorial(self, n):
        # Check for negative numbers
        if n &lt; 0:
            print("Factorials are only defined on non-negative integers.")
            return
        # Base Case: 0! or 1! is 1
        if n &lt;= 1:
            return 1
        # Recursive Step: n * (n-1)!
        return n * self.factorial(n - 1)

def main():
    # Create an instance of the class and call the method
    math_tools = MathTools()
    number = 5
    print(str(number) + "! is " + str(math_tools.factorial(number)))

main()
            </code>
        </program>
        
        <p>
           See if you can spot the differences in the Java version below.
        </p>
        <p>
            Here is the equivalent Java code:
        </p>
        <program interactive="activecode" language="java">
            <code>
public class MathTools {
    public static int factorial(int n) {
        // Check for negative numbers
        if (n &lt; 0) {
            System.out.println("Factorials are only defined on non-negative integers.");
            return -1;  // Return -1 to indicate error
        }
        // Base Case: 0! or 1! is 1
        if (n &lt;= 1) {
            return 1;
        }
        // Recursive Step: n * (n-1)!
        return n * factorial(n - 1);
    }

    public static void main(String[] args) {
        int number = 5;
        System.out.println(number + "! is " + factorial(number));
    }
}
            </code>
        </program>
        <p>
           Notice the key differences from Python: instead of <c>def factorial(n):</c>, Java uses <c>public static int factorial(int n)</c> which declares the method's visibility as <c>public</c>, that it belongs to the class rather than an instance (hence, <c>static</c>), the return type as integer, and the parameter type also as integer. The recursive logic—base case and recursive step—remains identical to Python, but all code blocks use curly braces <c>{}</c> instead of indentation.
        </p>
    </section>

    <section xml:id="java-patterns-for-recursion">
        <title>Common Recursive Patterns</title>

        <p>
            In many recursive algorithms, the recursive calls need extra information that the original caller shouldn't have to provide. For example, to recursively process an array, you need to keep track of the current position (index). To traverse a tree, you need to know the current node. This extra information clutters the public-facing method signature.
        </p>
        <p>
            A common pattern to solve this is using a private helper method. This pattern lets you create a clean, simple public method that users will call, while the private helper method handles the complex details of the recursion. The public method typically makes the initial call to the private helper, providing the necessary starting values for the extra parameters.
        </p>
        <p>
            Let's see this pattern in action with an example that calculates the sum of all elements in an integer array. The public <c>sum</c> method only takes the array, but the private <c>sumHelper</c> method also takes an index to track its progress through the array.
        </p>
        
        <p>
            You're likely familiar with how some recursive algorithms, like the naive Fibonacci implementation,
            are elegant but inefficient, due to branching recursive calls filling the call stack. A common pattern to solve
            this is using a private helper method. 
            </p>
            <p>
                The following example demonstrates this pattern. The public <c>fib</c> method provides a simple entry point, while the private <c>fibHelper</c> method performs the efficient recursion by carrying its state (the previous two numbers) in its parameters.
            </p>
            <p>
                The following Java code demonstrates a similar pattern.
            </p>

            <program interactive="activecode" language="java">
                <code>
                public class FibonacciExample {
                    public int fib(int n) {
                        if (n &lt; 0) {
                            throw new IllegalArgumentException("Input cannot be negative.");
                        }
                        // Initial call to the recursive helper with depth 0.
                        return this._fibHelper(n, 0, 1, 0);
                    }
                    private int _fibHelper(int count, int a, int b, int depth) {
                        // Create an indent string based on the recursion depth.
                        String indent = "  ".repeat(depth);
                        // Print when the method is entered (pushed onto the stack).
                        System.out.printf("%s[&gt;&gt;] ENTERING _fibHelper(count=%d, a=%d, b=%d)%n", indent, count, a, b);
                        // Base Case: When the count reaches 0, 'a' holds the result.
                        if (count == 0) {
                            System.out.printf("%s[&lt;&lt;] EXITING (Base Case) -&gt; returns %d%n", indent, a);
                            return a;
                        }
                        // Recursive Step.
                        int result = this._fibHelper(count - 1, b, a + b, depth + 1);
                        // Print when the method exits (popped from the stack).
                        System.out.printf("%s[&lt;&lt;] EXITING (Recursive Step) -&gt; passing %d%n", indent, result);
                        return result;
                    }
                    public static void main(String[] args) {
                        FibonacciExample calculator = new FibonacciExample();
                        int n = 4; // Let's calculate the 4th Fibonacci number.
                        System.out.printf("--- Calculating fib(%d) ---%n", n);
                        int result = calculator.fib(n);
                        System.out.println("--------------------------");
                        System.out.printf("The %dth Fibonacci number is: %d%n", n, result);
                    }
                }
                </code>
            </program>
            <p>
            This helper method approach is significantly more efficient in terms of time than the classic branching recursion (where <c>fib(n)</c> calls <c>fib(n-1)</c> and <c>fib(n-2)</c>). The branching model has an exponential time complexity of roughly O(2^n) because it re-calculates the same values many times. In contrast, our helper method has a linear time complexity of O(n), as it avoids re-computation by carrying the previous two results (a and b) forward into the next call.
        </p>
        <p>
            However, regarding memory efficiency, the comparison is different. The maximum depth of the call stack for both the naive and the helper method is proportional to n, giving them both a space complexity of O(n). This means that while the helper method is much faster, it is equally vulnerable to a <c>StackOverflowError</c> for very large values of n. Because Java does not perform tail-call optimization, any recursive solution that goes too deep will exhaust the stack memory, regardless of its time efficiency. For true memory efficiency (O(1) space), an iterative loop-based solution is superior.
        </p>
        <p>
            The following Python code demonstrates the same pattern, using a public method to initiate the calculation and a private helper method to perform the recursion.
        </p>
        <program interactive="activecode" language="python">
                <code>
                class FibonacciExample:
                    def fib(self, n: int) -&gt; int:
                        """
                        Public method to start the Fibonacci calculation.
                        """
                        if n &lt; 0:
                            raise ValueError("Input cannot be negative.")
                        # Initial call to the recursive helper with depth 0.
                        return self._fib_helper(n, 0, 1, 0)

                    def _fib_helper(self, count: int, a: int, b: int, depth: int) -&gt; int:
                        """
                        Private helper that performs the tail recursion to find the number.
                        """
                        # Create an indent string based on the recursion depth.
                        indent = "  " * depth
                        # Print when the method is entered (pushed onto the stack).
                        print(f"{indent}[&gt;&gt;] ENTERING _fib_helper(count={count}, a={a}, b={b})")

                        # Base Case: When the count reaches 0, 'a' holds the result.
                        if count == 0:
                            print(f"{indent}[&lt;&lt;] EXITING (Base Case) -&gt; returns {a}")
                            return a
                            
                        # Recursive Step.
                        result = self._fib_helper(count - 1, b, a + b, depth + 1)
                        # Print when the method exits (popped from the stack).
                        print(f"{indent}[&lt;&lt;] EXITING (Recursive Step) -&gt; passing {result}")
                        return result

                # The standard Python entry point, equivalent to Java's `main` method.
                if __name__ == "__main__":
                    calculator = FibonacciExample()
                    n = 4  # Let's calculate the 4th Fibonacci number.
                    print(f"--- Calculating fib({n}) ---")
                    result = calculator.fib(n)
                    print("--------------------------")
                    print(f"The {n}th Fibonacci number is: {result}")
                </code>
            </program>
    </section>
    <section xml:id="recursion-limits-in-java">
        <title>Recursion Limits: Python vs. Java</title>
        <p>
            The consequence of deep recursion, running out of stack space, is a concept you've already encountered in Python. Java handles this in a very similar way, throwing an error when the call stack depth is exceeded.
        </p>
        <p>
            The key difference is the name of the error:
        </p>
        <ul>
            <li>In Python, this raises a <c>RecursionError</c>.</li>
            <li>In Java, this throws a <c>StackOverflowError</c>.</li>
        </ul>
        <p>
            Neither language supports <idx> tail call optimization </idx><term>tail call optimization</term>, so the practical limits on recursion depth are a factor in both. If an algorithm requires thousands of recursive calls, an iterative (loop-based) approach is the preferred solution in both Python and Java.
        </p>
        <p>
            The following Python code demonstrates a situation where a function calls itself indefinitely without a base case, leading to aRecursionError.
        </p>
        <program interactive="activecode" language="python">
            <code>
                def cause_recursion_error():
                    """
                    This function calls itself without a base case, guaranteeing an error.
                    """
                    cause_recursion_error()

                # Standard Python entry point
                if __name__ == "__main__":
                    print("Calling the recursive function... this will end in an error!")
                    
                    # This line starts the infinite recursion.
                    # Python will stop it and raise a RecursionError automatically.
                    cause_recursion_error()
            </code>
        </program>

        <p>
            The following Java code demonstrates a similar situation, where a method calls itself indefinitely without a base case, leading to a StackOverflowError.
        </p>
        <program interactive="activecode" language="java">
            <code>
                public class Crash {
                    public static void causeStackOverflow() {
                        // This method calls itself endlessly without a stopping condition (a base case).
                        // Each call adds a new layer to the program's call stack.
                        // Eventually, the stack runs out of space, causing the error.
                        causeStackOverflow();
                    }
                    // A main method is required to run the program.
                    public static void main(String[] args) {
                        System.out.println("Calling the recursive method... this will end in an error!");
                        // This line starts the infinite recursion.
                        causeStackOverflow();
                    }
                }
            </code>
        </program>
    </section>
</chapter>